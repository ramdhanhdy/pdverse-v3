================================================================
Directory Structure
================================================================
app/api/chat/route.ts
app/api/documents/[id]/route.ts
app/api/enhance-metadata/route.ts
app/api/files/[id]/route.ts
app/api/files/route.ts
app/api/pdf-metadata/route.ts
app/api/python-backend/route.ts
app/api/search/route.ts
app/api/storage/usage/route.ts
app/api/upload/route.ts
app/api/uploads/[filename]/route.ts
app/components/search-form.tsx
app/dashboard/chat/[id]/page.tsx
app/dashboard/chat/components/ChatModeSelector.tsx
app/dashboard/chat/history/page.tsx
app/dashboard/chat/page.tsx
app/dashboard/files/[id]/page-iframe.tsx
app/dashboard/files/[id]/page.tsx
app/dashboard/files/page.tsx
app/dashboard/files/upload/page.tsx
app/dashboard/layout.tsx
app/dashboard/layout.tsx.fix
app/dashboard/layout.tsx.new
app/dashboard/page.tsx
app/dashboard/settings/page.tsx
app/globals.css
app/layout.tsx
app/lib/logger.ts
app/lib/python-backend.ts
app/lib/utils.ts
app/page.tsx
components/animated-sidebar-button.tsx
components/theme-provider.tsx
components/theme-toggle.tsx
components/ui/badge.tsx
components/ui/button.tsx
components/ui/card.tsx
components/ui/dialog.tsx
components/ui/dropdown-menu.tsx
components/ui/input.tsx
components/ui/label.tsx
components/ui/popover.tsx
components/ui/select.tsx
components/ui/separator.tsx
components/ui/skeleton.tsx
components/ui/switch.tsx
components/ui/tabs.tsx
components/ui/textarea.tsx
lib/ai/gemini.ts
lib/db.ts
lib/db/index.ts
lib/db/migrate.ts
lib/db/migrations/add_enhanced_metadata.ts
lib/db/migrations/add_full_text_search.ts
lib/db/reset_database.ts
lib/pdf/processor.ts
lib/pdf/types.ts
lib/python-backend.ts
lib/utils.ts
next.config.js
package.json
python-backend/api.py
python-backend/app.py
python-backend/config.py
python-backend/db.py
python-backend/file_storage.py
python-backend/init_db.py
python-backend/installation.md
python-backend/llm_helper.py
python-backend/pdf_processing.py
python-backend/readme.md
python-backend/requirements.txt
python-backend/search.py
python-backend/test_embedding.py
python-backend/test_pdf_processing.py
python-backend/utils.py
tailwind.config.js
tsconfig.json

================================================================
Files
================================================================

================
File: app/api/chat/route.ts
================
// api/chat/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { streamText } from 'ai';
import { openai } from '@ai-sdk/openai';

export const runtime = 'edge';

export async function POST(req: NextRequest) {
  try {
    const { messages, fileIds, chatId, model = 'gpt-4o', temperature = 0.7, maxTokens = 4096, data, chatMode } = await req.json();
    console.log('Chat API received:', { messages, fileIds, chatId, model, temperature, maxTokens, data });

    // Handle Python backend response if provided
    if (data?.pythonBackendResponse) {
      console.log('Returning pythonBackendResponse:', data.pythonBackendResponse);
      return NextResponse.json({ content: data.pythonBackendResponse, chatId });
    }

    // Document mode: Call Python backend
    if (fileIds && fileIds.length > 0) {
      console.log('Document mode: Calling Python backend');
      const lastUserMessage = messages.find((m: any) => m.role === 'user');
      if (!lastUserMessage) {
        throw new Error('No user message found');
      }

      const pythonBackendUrl = process.env.PYTHON_BACKEND_URL || 'http://localhost:8000';
      const apiKey = process.env.OPENAI_API_KEY;
      if (!apiKey) {
        throw new Error('OPENAI_API_KEY not configured in environment');
      }

      const response = await fetch(`${pythonBackendUrl}/query`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          query: lastUserMessage.content,
          document_id: fileIds[0],
          chat_mode: 'document',
          api_key: apiKey,
        }),
        signal: AbortSignal.timeout(30000),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('Python backend error:', errorText);
        throw new Error(`Failed to query Python backend: ${errorText}`);
      }

      const result = await response.json();
      console.log('Python backend response:', result);
      return NextResponse.json({ content: result.response, chatId });
    }

    // General mode: Direct OpenAI call with streamText
    if (chatMode === 'general') {
      console.log('Explicit general mode: Using OpenAI');
      // Direct OpenAI call with general system prompt
      const systemContent = 'You are a helpful AI assistant';
      const response = await streamText({
        model: openai(model),
        system: systemContent,
        messages: messages.map((msg: any) => ({ role: msg.role, content: msg.content })),
        temperature,
        maxTokens,
      });
      return response.toDataStreamResponse();
    }

    // General mode: Direct OpenAI call with streamText
    console.log('General mode: Using OpenAI fallback');
    if (!process.env.OPENAI_API_KEY) {
      throw new Error('OPENAI_API_KEY not configured in environment');
    }

    console.log('Initiating streamText with model:', model);
    const systemContent = 'You are an AI assistant specialized in helping users with PDF documents. You can analyze content, extract information, and answer questions about documents.';
    const response = await streamText({
      model: openai(model),
      system: systemContent,
      messages: messages.map((msg: any) => ({ role: msg.role, content: msg.content })),
      temperature,
      maxTokens,
    });

    console.log('streamText response initiated');
    // Return streaming response directly for useChat
    return response.toDataStreamResponse();
  } catch (error) {
    console.error('Error in chat API:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to process your request' },
      { status: 500 }
    );
  }
}

================
File: app/api/documents/[id]/route.ts
================
import { NextResponse } from 'next/server';

export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const { id } = params;
    const pythonBackendUrl = process.env.PYTHON_BACKEND_URL || 'http://localhost:8000';
    
    const response = await fetch(`${pythonBackendUrl}/document/${id}`, {
      headers: {
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const errorText = await response.text();
      return NextResponse.json({ error: errorText }, { status: response.status });
    }

    const documentData = await response.json();
    return NextResponse.json(documentData);
    
  } catch (error) {
    console.error('Document fetch error:', error);
    return NextResponse.json(
      { error: 'Failed to fetch document details' },
      { status: 500 }
    );
  }
}

================
File: app/api/enhance-metadata/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { getPdfMetadata, savePdfMetadata, getFileById } from "@/lib/db";
import { enhanceMetadataWithGemini } from "@/lib/ai/gemini";
import fs from "fs";
import path from "path";

export async function POST(request: NextRequest) {
  try {
    console.log("Enhance metadata API called");
    const data = await request.json();
    const { fileId } = data;
    console.log("File ID:", fileId);

    if (!fileId) {
      return NextResponse.json(
        { error: "File ID is required" },
        { status: 400 }
      );
    }

    // Get current metadata
    const metadata = getPdfMetadata(fileId);
    console.log("Retrieved metadata:", metadata ? "Found" : "Not found");
    if (!metadata) {
      return NextResponse.json(
        { error: "Metadata not found for this file" },
        { status: 404 }
      );
    }

    // Get the file record to get the actual filename
    const fileRecord = getFileById(fileId);
    console.log("File record:", fileRecord ? "Found" : "Not found", fileRecord);
    if (!fileRecord) {
      return NextResponse.json(
        { error: "File record not found" },
        { status: 404 }
      );
    }

    // Get file path to extract text
    const uploadsDir = path.join(process.cwd(), "uploads");
    const filePath = path.join(uploadsDir, fileRecord.filename);
    console.log("File path:", filePath);

    if (!fs.existsSync(filePath)) {
      console.log("PDF file not found at path:", filePath);
      return NextResponse.json(
        { error: "PDF file not found" },
        { status: 404 }
      );
    }

    // Read file content
    const fileBuffer = fs.readFileSync(filePath);
    const fileData = new Uint8Array(fileBuffer);

    // Extract text from PDF
    const { extractPdfMetadata } = await import("@/lib/pdf/mupdf-parser.mjs");
    console.log("Extracting PDF text...");
    const extractionResult = await extractPdfMetadata(filePath);
    console.log("Text extraction complete, text length:", extractionResult.fullText.length);
    const { fullText } = extractionResult;

    // Convert DB metadata to the format expected by enhanceMetadataWithGemini
    const metadataForEnhancement = {
      title: metadata.title || "",
      author: metadata.author || "",
      subject: metadata.subject || "",
      keywords: metadata.keywords || "",
      creator: metadata.creator || "",
      producer: metadata.producer || "",
      pageCount: metadata.page_count || 0,
      creationDate: metadata.creation_date || "",
      modificationDate: metadata.modification_date || "",
      summary: metadata.summary || "",
      documentType: metadata.document_type || "",
      topics: metadata.topics ? metadata.topics.split(",").map(t => t.trim()) : [],
      aiEnhanced: Boolean(metadata.ai_enhanced),
      needsReview: Boolean(metadata.needs_review)
    };

    // Enhance metadata with Gemini
    console.log("Calling Gemini API...");
    const enhancedMetadata = await enhanceMetadataWithGemini(
      metadataForEnhancement,
      fullText,
      filePath
    );
    console.log("Gemini API response received");
    console.log("Enhanced metadata from Gemini:", JSON.stringify(enhancedMetadata, null, 2));

    // Save enhanced metadata back to database
    console.log("Saving enhanced metadata to database");
    
    // Ensure all values are of the correct type for SQLite
    const sanitizedMetadata = {
      fileId,
      title: String(enhancedMetadata.title || ''),
      author: String(enhancedMetadata.author || ''),
      subject: String(enhancedMetadata.subject || ''),
      keywords: String(enhancedMetadata.keywords || ''),
      creator: String(enhancedMetadata.creator || ''),
      producer: String(enhancedMetadata.producer || ''),
      pageCount: Number(enhancedMetadata.pageCount || 0),
      creationDate: String(enhancedMetadata.creationDate || ''),
      modificationDate: String(enhancedMetadata.modificationDate || ''),
      summary: String(enhancedMetadata.summary || ''),
      documentType: String(enhancedMetadata.documentType || ''),
      // Convert topics array to string
      topics: Array.isArray(enhancedMetadata.topics) 
        ? enhancedMetadata.topics.join(", ") 
        : String(enhancedMetadata.topics || ''),
      // Keep as boolean values - the savePdfMetadata function will handle conversion to SQLite integers
      aiEnhanced: Boolean(enhancedMetadata.aiEnhanced),
      needsReview: Boolean(enhancedMetadata.needsReview)
    };
    
    console.log("Sanitized metadata:", JSON.stringify(sanitizedMetadata, null, 2));
    const updatedMetadata = await savePdfMetadata(sanitizedMetadata);
    console.log("Metadata successfully enhanced and saved");
    return NextResponse.json({ 
      success: true, 
      metadata: updatedMetadata 
    });
  } catch (error) {
    console.error("Error enhancing metadata:", error);
    return NextResponse.json(
      { error: "Failed to enhance metadata: " + (error instanceof Error ? error.message : String(error)) },
      { status: 500 }
    );
  }
}

================
File: app/api/files/[id]/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { getFileById } from "@/lib/db";

export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const id = params.id;
    const file = getFileById(id);

    if (!file) {
      return NextResponse.json(
        { error: "File not found" },
        { status: 404 }
      );
    }

    return NextResponse.json(file);
  } catch (error) {
    console.error("Error fetching file:", error);
    return NextResponse.json(
      { error: "Failed to fetch file" },
      { status: 500 }
    );
  }
}

================
File: app/api/files/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { getDocumentsFromPythonBackend } from "@/lib/python-backend";

const PYTHON_BACKEND_URL = process.env.PYTHON_BACKEND_URL || 'http://localhost:8000';

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const id = searchParams.get("id");

    if (id) {
      try {
        // Use proper Python backend endpoint
        const response = await fetch(
          `${PYTHON_BACKEND_URL}/document/${id}`
        );
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const document = await response.json();
        return NextResponse.json(document);
      } catch (error) {
        console.error("Error fetching file:", error);
        return NextResponse.json(
          { error: "File not found or backend error" },
          { status: 404 }
        );
      }
    }
    
    // Get all files from Python backend
    try {
      const response = await fetch(`${PYTHON_BACKEND_URL}/documents`);
      if (!response.ok) throw new Error("Failed to fetch documents");
      const documents = await response.json();
      return NextResponse.json({ files: documents });
    } catch (error) {
      console.error("Error fetching files from Python backend:", error);
      return NextResponse.json(
        { error: "Failed to fetch files from Python backend" },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error("Error in files API route:", error);
    return NextResponse.json(
      { error: "Failed to process request" },
      { status: 500 }
    );
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const id = searchParams.get("id");

    if (!id) {
      return NextResponse.json(
        { error: "Document ID is required" },
        { status: 400 }
      );
    }

    const deleteResponse = await fetch(`${PYTHON_BACKEND_URL}/document/${id}`, {
      method: 'DELETE'
    });

    if (!deleteResponse.ok) {
      const error = await deleteResponse.json();
      throw new Error(error.detail || 'Failed to delete document');
    }

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error("Error deleting document:", error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : "Deletion failed" },
      { status: 500 }
    );
  }
}

================
File: app/api/pdf-metadata/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { getDocumentFromPythonBackend } from "@/lib/python-backend";
import { getFileById } from "@/lib/db";

export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const fileId = searchParams.get("fileId");

    if (!fileId) {
      return NextResponse.json(
        { error: "File ID is required" },
        { status: 400 }
      );
    }
    
    // Bypass SQLite check and use direct Python backend ID
    const pythonBackendId = fileId; // Now using fileId directly as pythonBackendId
    
    try {
      // Get the metadata from the Python backend
      // We need to get the Python backend document ID from the file record
      // This should be stored in the file record's metadata field
      const metadata = await getDocumentFromPythonBackend(pythonBackendId);
      
      return NextResponse.json({ metadata });
    } catch (backendError) {
      console.error("Error fetching metadata from Python backend:", backendError);
      return NextResponse.json(
        { error: "Failed to fetch metadata from Python backend" },
        { status: 500 }
      );
    }
  } catch (error) {
    console.error("Error fetching PDF metadata:", error);
    return NextResponse.json(
      { error: "Failed to fetch PDF metadata" },
      { status: 500 }
    );
  }
}

================
File: app/api/python-backend/route.ts
================
// File: app/api/python-backend/route.ts
import { NextRequest, NextResponse } from "next/server";

// Get Python backend URL from environment variable or use default
const PYTHON_BACKEND_URL = process.env.PYTHON_BACKEND_URL || 'http://localhost:8000';

/**
 * Proxy requests to the Python backend
 */
export async function POST(request: NextRequest) {
  try {
    const endpoint = request.nextUrl.searchParams.get("endpoint") || "";
    const url = `${PYTHON_BACKEND_URL}/${endpoint}`;
    
    // Forward the request body
    const body = await request.text();
    
    // Forward the request to the Python backend
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': request.headers.get('Content-Type') || 'application/json',
      },
      body,
    });
    
    // Get the response from the Python backend
    const data = await response.json();
    
    // Return the response
    return NextResponse.json(data, { status: response.status });
  } catch (error) {
    console.error("Error proxying to Python backend:", error);
    return NextResponse.json(
      { error: "Failed to communicate with Python backend" },
      { status: 500 }
    );
  }
}

/**
 * Proxy GET requests to the Python backend
 */
export async function GET(request: NextRequest) {
  try {
    const endpoint = request.nextUrl.searchParams.get("endpoint") || "";
    
    // Build the URL with query parameters
    const url = new URL(`${PYTHON_BACKEND_URL}/${endpoint}`);
    
    // Copy all query parameters except 'endpoint'
    for (const [key, value] of Array.from(request.nextUrl.searchParams.entries())) {
      if (key !== 'endpoint') {
        url.searchParams.append(key, value);
      }
    }
    
    // Forward the request to the Python backend
    const response = await fetch(url.toString(), {
      method: 'GET',
      headers: {
        'Accept': 'application/json',
      },
    });
    
    // Get the response from the Python backend
    const data = await response.json();
    
    // Return the response
    return NextResponse.json(data, { status: response.status });
  } catch (error) {
    console.error("Error proxying to Python backend:", error);
    return NextResponse.json(
      { error: "Failed to communicate with Python backend" },
      { status: 500 }
    );
  }
}

/**
 * Proxy DELETE requests to the Python backend
 */
export async function DELETE(request: NextRequest) {
  try {
    const endpoint = request.nextUrl.searchParams.get("endpoint") || "";
    const url = `${PYTHON_BACKEND_URL}/${endpoint}`;
    
    // Forward the request to the Python backend
    const response = await fetch(url, {
      method: 'DELETE',
    });
    
    // Get the response from the Python backend
    const data = await response.json();
    
    // Return the response
    return NextResponse.json(data, { status: response.status });
  } catch (error) {
    console.error("Error proxying to Python backend:", error);
    return NextResponse.json(
      { error: "Failed to communicate with Python backend" },
      { status: 500 }
    );
  }
}

================
File: app/api/search/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import { logger } from "@/lib/logger";

const PYTHON_BACKEND_URL = process.env.PYTHON_BACKEND_URL || 'http://localhost:8000';

export async function POST(request: NextRequest) {
  try {
    const { 
      query, 
      documentId, 
      limit = 10, 
      offset = 0, 
      searchType = 'hybrid',
      vectorWeight = 0.65,
      textWeight = 0.35,
      filters = {},
    } = await request.json();

    logger.debug(`Received query: '${query}'`);
    
    if (!query || typeof query !== 'string') {
      return NextResponse.json({ error: "Invalid query: must be a non-empty string" }, { status: 400 });
    }

    // Generate vector embedding for the query
    const vectorResponse = await fetch(`${PYTHON_BACKEND_URL}/embed`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ text: query }),
    });
    const vectorQuery = await vectorResponse.json().then(data => data.embedding);

    const response = await fetch(`${PYTHON_BACKEND_URL}/search`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({
        query,
        document_id: documentId,
        limit,
        offset,
        search_type: searchType,
        vector_query: vectorQuery,
        vector_weight: vectorWeight,
        text_weight: textWeight,
        filters,
      }),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.detail || 'Search failed');
    }

    const { results, total } = await response.json();
    return NextResponse.json({ 
      query,
      results: results.map((r: any) => ({
        ...r,
        score: r.score,
        content: r.content,
      })),
      count: total,
    });
  } catch (error) {
    console.error("Error searching documents:", error);
    return NextResponse.json({ error: "Failed to search documents" }, { status: 500 });
  }
}

================
File: app/api/storage/usage/route.ts
================
import { NextResponse } from 'next/server';

export const runtime = 'edge';

export async function GET() {
  try {
    // In a real implementation, you would calculate actual storage usage
    // For now, we'll return mock data
    // This could be enhanced to check IndexedDB or localStorage size
    
    // Mock data for demonstration
    const mockUsage = {
      used: 25 * 1024 * 1024, // 25MB in bytes
      total: 100 * 1024 * 1024, // 100MB in bytes
    };
    
    return NextResponse.json(mockUsage);
  } catch (error) {
    console.error('Error getting storage usage:', error);
    return NextResponse.json(
      { error: 'Failed to get storage usage' },
      { status: 500 }
    );
  }
}

================
File: app/api/upload/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import path from "path";
import fs from "fs";
import { v4 as uuidv4 } from "uuid";
import { isValidPdf } from "@/lib/utils";

const UPLOADS_DIR = path.join(process.cwd(), "uploads");
if (!fs.existsSync(UPLOADS_DIR)) {
  fs.mkdirSync(UPLOADS_DIR, { recursive: true });
}

const PYTHON_BACKEND_URL = process.env.PYTHON_BACKEND_URL || 'http://localhost:8000';

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const file = formData.get("file") as File;

    if (!file) {
      return NextResponse.json(
        { error: "No file provided" },
        { status: 400 }
      );
    }

    if (!isValidPdf(file)) {
      return NextResponse.json(
        { error: "Only PDF files are allowed" },
        { status: 400 }
      );
    }

    const uniqueId = uuidv4();
    const fileExtension = path.extname(file.name);
    const filename = `${uniqueId}${fileExtension}`;
    const filePath = path.join(UPLOADS_DIR, filename);

    const buffer = await file.arrayBuffer();
    fs.writeFileSync(filePath, Buffer.from(buffer));

    // Prepare form data for Python backend
    const backendFormData = new FormData();
    backendFormData.append("file", new Blob([buffer]), filename);
    // Optionally add title and author if present in the original formData
    const title = formData.get("docTitle") as string | null;
    const author = formData.get("docAuthor") as string | null;
    if (title) backendFormData.append("docTitle", title);
    if (author) backendFormData.append("docAuthor", author);

    // Send to Python backend
    const processingResponse = await fetch(`${PYTHON_BACKEND_URL}/upload`, {
      method: 'POST',
      body: backendFormData,
    });

    if (!processingResponse.ok) {
      const errorData = await processingResponse.json();
      throw new Error(errorData.detail || "Failed to process PDF in backend");
    }

    const result = await processingResponse.json();

    return NextResponse.json({
      success: result.status === 'success',
      documentId: result.id,
      filename: result.filename,
    });
  } catch (error) {
    console.error("Error uploading file:", error);
    return NextResponse.json(
      { error: "Failed to upload file" },
      { status: 500 }
    );
  }
}

================
File: app/api/uploads/[filename]/route.ts
================
import { NextRequest, NextResponse } from "next/server";
import path from "path";
import fs from "fs";

export async function GET(
  request: NextRequest,
  { params }: { params: { filename: string } }
) {
  try {
    const filename = params.filename;
    console.log(`Serving file: ${filename}`);
    
    // Prevent path traversal attacks
    if (filename.includes('..')) {
      console.error(`Path traversal attempt detected: ${filename}`);
      return NextResponse.json(
        { error: "Invalid filename" },
        { status: 400 }
      );
    }
    
    const filePath = path.join(process.cwd(), "uploads", filename);
    console.log(`Full file path: ${filePath}`);
    
    // Check if file exists
    if (!fs.existsSync(filePath)) {
      console.error(`File not found: ${filePath}`);
      return NextResponse.json(
        { error: "File not found" },
        { status: 404 }
      );
    }
    
    // Check if file is readable
    try {
      fs.accessSync(filePath, fs.constants.R_OK);
      console.log(`File is readable: ${filePath}`);
    } catch (err) {
      console.error(`File is not readable: ${filePath}`, err);
      return NextResponse.json(
        { error: "File cannot be read" },
        { status: 403 }
      );
    }
    
    // Get file stats
    const stats = fs.statSync(filePath);
    console.log(`File size: ${stats.size} bytes`);
    
    // Read file content
    const fileBuffer = fs.readFileSync(filePath);
    
    console.log(`Successfully serving file: ${filename} (${fileBuffer.length} bytes)`);
    
    // Return file with proper content type
    return new NextResponse(fileBuffer, {
      headers: {
        "Content-Type": "application/pdf",
        "Content-Disposition": `inline; filename="${filename}"`,
        "Content-Length": String(fileBuffer.length),
        "Cache-Control": "public, max-age=31536000",
      },
    });
  } catch (error) {
    console.error("Error serving file:", error);
    return NextResponse.json(
      { error: "Failed to serve file" },
      { status: 500 }
    );
  }
}

================
File: app/components/search-form.tsx
================
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { useState } from "react";
import { searchDocumentsInPythonBackend } from "@/lib/python-backend";

interface SearchFormProps {
  onSearch: (results: any[]) => void;
}

export function SearchForm({ onSearch }: SearchFormProps) {
  const [query, setQuery] = useState("");
  const [searchType, setSearchType] = useState<'fulltext' | 'vector' | 'hybrid'>("fulltext"); // Typed union
  const [isSearching, setIsSearching] = useState(false);

  const handleSearch = async () => {
    setIsSearching(true);
    try {
      const { results } = await searchDocumentsInPythonBackend(query, { search_type: searchType }); // Updated to snake_case

      const transformedResults = results.map((r: any) => ({
        chunk: {
          id: r.chunk_id,
          documentId: r.document_id,
          pageNumber: r.page_number,
          content: r.content
        },
        fileInfo: {
          id: r.document_id,
          filename: r.document_info.title,
          original_filename: r.document_info.title
        },
        score: r.score
      }));

      onSearch(transformedResults);
    } finally {
      setIsSearching(false);
    }
  };

  return (
    <div className="grid gap-2">
      <div className="flex gap-2 items-center">
        <Input
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          placeholder="Enter search query..."
          className="flex-1"
        />
        <Select value={searchType} onValueChange={(v) => setSearchType(v as 'fulltext' | 'vector' | 'hybrid')}>
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Search type" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="fulltext">Full Text</SelectItem>
            <SelectItem value="vector">Semantic</SelectItem>
            <SelectItem value="hybrid">Hybrid</SelectItem>
          </SelectContent>
        </Select>
        <Button onClick={handleSearch} disabled={isSearching}>
          {isSearching ? "Searching..." : "Search"}
        </Button>
      </div>
    </div>
  );
}

================
File: app/dashboard/chat/[id]/page.tsx
================
"use client";

import { useState, useRef, useEffect } from "react";
import { useParams, useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";

type Message = {
  id: string;
  role: "user" | "assistant";
  content: string;
  timestamp: Date;
};

type ChatSession = {
  id: string;
  title: string;
  createdAt: Date;
  messages: Message[];
  attachedFiles?: {
    id: number;
    name: string;
  }[];
};

// Function to fetch chat session from API
const fetchChatSession = async (id: string): Promise<ChatSession> => {
  try {
    const response = await fetch(`/api/chat/sessions/${id}`);
    if (!response.ok) {
      throw new Error('Failed to fetch chat session');
    }
    const data = await response.json();
    
    // Convert string timestamps to Date objects
    const messages = data.messages.map((msg: any) => ({
      ...msg,
      timestamp: new Date(msg.timestamp)
    }));
    
    return {
      ...data,
      messages,
      createdAt: new Date(data.createdAt)
    };
  } catch (error) {
    console.error('Error fetching chat session:', error);
    // Fallback to mock data if API fails
    return getChatSession(id);
  }
};

// Mock function as fallback
const getChatSession = (id: string): ChatSession => {
  const mockMessages: Message[] = [
    {
      id: "assistant-1",
      role: "assistant",
      content: "Hello! How can I help you with your PDF documents today?",
      timestamp: new Date(Date.now() - 1000 * 60 * 30),
    },
    {
      id: "user-1",
      role: "user",
      content: "I have a PDF about climate change. Can you summarize it for me?",
      timestamp: new Date(Date.now() - 1000 * 60 * 29),
    },
    {
      id: "assistant-2",
      role: "assistant",
      content: "I'd be happy to help summarize your climate change document. Could you please attach the PDF so I can analyze its contents?",
      timestamp: new Date(Date.now() - 1000 * 60 * 28),
    },
    {
      id: "user-2",
      role: "user",
      content: "I've attached the document 'Climate_Report_2023.pdf'",
      timestamp: new Date(Date.now() - 1000 * 60 * 27),
    },
    {
      id: "assistant-3",
      role: "assistant",
      content: "Thank you for sharing the Climate Report 2023. Based on my analysis, the document covers the following key points:\n\n1. Global temperatures have risen by 1.1Â°C since pre-industrial times\n2. Carbon emissions continue to increase despite mitigation efforts\n3. Sea levels are rising at an accelerated rate\n4. Extreme weather events are becoming more frequent\n5. The report recommends immediate action to reduce emissions by 45% by 2030\n\nWould you like me to elaborate on any specific section of the report?",
      timestamp: new Date(Date.now() - 1000 * 60 * 25),
    },
    {
      id: "user-3",
      role: "user",
      content: "Can you tell me more about the recommended actions in the report?",
      timestamp: new Date(Date.now() - 1000 * 60 * 24),
    },
    {
      id: "assistant-4",
      role: "assistant",
      content: "Certainly! The Climate Report 2023 outlines several recommended actions:\n\n1. **Immediate Emission Reductions**: Cut global carbon emissions by 45% by 2030 and reach net-zero by 2050\n\n2. **Renewable Energy Transition**: Accelerate the shift from fossil fuels to renewable energy sources like solar, wind, and hydroelectric power\n\n3. **Energy Efficiency Improvements**: Implement stricter building codes and industrial standards to reduce energy consumption\n\n4. **Transportation Reform**: Electrify public and private transportation systems and improve public transit infrastructure\n\n5. **Carbon Pricing**: Establish effective carbon pricing mechanisms to incentivize emission reductions\n\n6. **Natural Carbon Sinks**: Protect and restore forests, wetlands, and other ecosystems that absorb carbon\n\n7. **Climate Finance**: Developed countries should fulfill their pledge to provide $100 billion annually to support climate action in developing nations\n\n8. **Adaptation Measures**: Invest in infrastructure and systems to adapt to already unavoidable climate impacts\n\nThe report emphasizes that these actions require coordination at international, national, and local levels, with particular responsibility falling on developed nations and major emitters.",
      timestamp: new Date(Date.now() - 1000 * 60 * 22),
    },
  ];

  return {
    id,
    title: "Climate Report Discussion",
    createdAt: new Date(Date.now() - 1000 * 60 * 30),
    messages: mockMessages,
    attachedFiles: [
      {
        id: 1,
        name: "Climate_Report_2023.pdf",
      },
    ],
  };
};

export default function ChatHistoryPage() {
  const params = useParams();
  const router = useRouter();
  const [chatSession, setChatSession] = useState<ChatSession | null>(null);
  const [input, setInput] = useState("");
  const [isLoading, setIsLoading] = useState(false);

  const messagesEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (params.id) {
      // Fetch the chat session from the API
      fetchChatSession(params.id as string).then(setChatSession);
    }
  }, [params.id]);

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [chatSession?.messages]);

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!input.trim() || !chatSession) return;

    // Add user message to UI immediately
    const userMessage: Message = {
      id: `user-${Date.now()}`,
      role: "user",
      content: input,
      timestamp: new Date(),
    };

    setChatSession({
      ...chatSession,
      messages: [...chatSession.messages, userMessage],
    });

    setInput("");
    setIsLoading(true);

    try {
      // Prepare messages for API in the format expected by the API
      const apiMessages = chatSession.messages.map(msg => ({
        role: msg.role,
        content: msg.content
      }));
      
      // Add the new user message
      apiMessages.push({
        role: "user",
        content: userMessage.content
      });

      // Get file IDs if any are attached
      const fileIds = chatSession.attachedFiles?.map(file => file.id) || [];

      // Make API call
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          messages: apiMessages,
          fileIds,
          chatId: chatSession.id
        }),
      });

      if (!response.ok) {
        throw new Error('Failed to get response from API');
      }

      const data = await response.json();
      
      // Add assistant response to chat
      const assistantMessage: Message = {
        id: `assistant-${Date.now()}`,
        role: "assistant",
        content: data.content || "Sorry, I couldn't process your request.",
        timestamp: new Date(),
      };

      setChatSession((prev) => {
        if (!prev) return prev;
        return {
          ...prev,
          messages: [...prev.messages, assistantMessage],
        };
      });
      
      // Update the chat session in the database
      await fetch(`/api/chat/sessions/${chatSession.id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          messages: [...chatSession.messages, userMessage, assistantMessage]
        }),
      });
      
    } catch (error) {
      console.error('Error in chat API call:', error);
      
      // Show error message
      const errorMessage: Message = {
        id: `assistant-${Date.now()}`,
        role: "assistant",
        content: "I'm sorry, there was an error processing your request. Please try again later.",
        timestamp: new Date(),
      };

      setChatSession((prev) => {
        if (!prev) return prev;
        return {
          ...prev,
          messages: [...prev.messages, errorMessage],
        };
      });
    } finally {
      setIsLoading(false);
    }
  };

  if (!chatSession) {
    return (
      <div className="flex flex-col items-center justify-center min-h-[60vh]">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
        <p className="mt-4 text-muted-foreground">Loading chat history...</p>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full">
      <div className="w-full max-w-3xl mx-auto flex flex-col h-full">
        <div className="mb-4 flex flex-col space-y-1.5">
          <div className="flex items-center gap-2">
            <Button
              onClick={() => router.push("/dashboard/chat")}
              variant="outline"
              size="icon"
              className="h-8 w-8"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="h-4 w-4"
              >
                <path d="m15 18-6-6 6-6" />
              </svg>
              <span className="sr-only">Back</span>
            </Button>
            <h1 className="text-2xl font-bold tracking-tight">{chatSession.title}</h1>
          </div>
          <div className="text-sm text-muted-foreground">
            {chatSession.createdAt.toLocaleString()}
          </div>
        </div>

        <Card className="flex-1 flex flex-col overflow-hidden">
          <CardContent className="flex-1 flex flex-col p-0">
            <div className="flex-1 overflow-y-auto p-6">
              {chatSession.messages.map((message) => (
                <div
                  key={message.id}
                  className={`mb-6 flex ${
                    message.role === "user" ? "justify-end" : "justify-start"
                  }`}
                >
                  <div
                    className={`max-w-[85%] rounded-lg px-4 py-3 ${
                      message.role === "user"
                        ? "bg-primary text-primary-foreground"
                        : "bg-muted"
                    }`}
                  >
                    <div className="whitespace-pre-wrap">{message.content}</div>
                    <div className="mt-2 text-xs opacity-70">
                      {message.timestamp.toLocaleTimeString()}
                    </div>
                  </div>
                </div>
              ))}
              <div ref={messagesEndRef} />
            </div>

            {chatSession.attachedFiles && chatSession.attachedFiles.length > 0 && (
              <div className="border-t p-3 bg-muted/50">
                <div className="text-sm font-medium mb-2">Attached Files:</div>
                <div className="flex flex-wrap gap-2">
                  {chatSession.attachedFiles.map((file) => (
                    <div
                      key={file.id}
                      className="flex items-center gap-2 rounded-full bg-muted px-3 py-1 text-sm"
                    >
                      <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="24"
                        height="24"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        className="h-4 w-4"
                      >
                        <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" />
                        <polyline points="14 2 14 8 20 8" />
                      </svg>
                      <span>{file.name}</span>
                    </div>
                  ))}
                </div>
              </div>
            )}

            <div className="border-t p-4">
              <form onSubmit={handleSubmit} className="flex gap-2">
                <input
                  type="text"
                  value={input}
                  onChange={(e) => setInput(e.target.value)}
                  placeholder="This is a historical view. Start a new chat to continue..."
                  className="flex-1 min-w-0 rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring"
                />
                <Button 
                  type="submit" 
                  disabled={!input.trim() || isLoading}
                >
                  {isLoading ? (
                    <span className="flex items-center gap-1">
                      <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                        <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                      </svg>
                      Sending
                    </span>
                  ) : (
                    "Send"
                  )}
                </Button>
              </form>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}

================
File: app/dashboard/chat/components/ChatModeSelector.tsx
================
import React from 'react';
import { Button } from '../../../../components/ui/button';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Check, ChevronDown, FileText, MessageSquare, Search, Zap } from 'lucide-react';
import { cn } from '../../../../lib/utils';

type ChatMode = 'document' | 'general' | 'search' | 'advanced';

interface ChatModeSelectorProps {
  currentMode: ChatMode;
  onModeChange: (mode: ChatMode) => void;
  compact?: boolean;
}

const modes = [
  {
    id: 'document',
    name: 'Document Chat',
    description: 'Chat with your documents',
    icon: FileText,
  },
  {
    id: 'general',
    name: 'General Chat',
    description: 'Chat without document context',
    icon: MessageSquare,
  },
  {
    id: 'search',
    name: 'Search Mode',
    description: 'Search across all documents',
    icon: Search,
  },
  {
    id: 'advanced',
    name: 'Advanced Analysis',
    description: 'Deep document analysis',
    icon: Zap,
  },
];

export function ChatModeSelector({ currentMode, onModeChange, compact = false }: ChatModeSelectorProps) {
  const currentModeData = modes.find((mode) => mode.id === currentMode) || modes[0];

  return (
    <div className={compact ? "flex items-center" : "flex items-center space-x-2 mb-4"}>
      <Popover>
        <PopoverTrigger asChild>
          {compact ? (
            <Button 
              variant="ghost" 
              size="icon"
              className="h-9 w-9 rounded-full p-0"
            >
              <currentModeData.icon className="h-5 w-5" />
              <span className="sr-only">{currentModeData.name}</span>
            </Button>
          ) : (
            <Button 
              variant="outline" 
              className="flex items-center justify-between w-[240px] font-normal"
            >
              <div className="flex items-center">
                <currentModeData.icon className="mr-2 h-4 w-4" />
                <span>{currentModeData.name}</span>
              </div>
              <ChevronDown className="ml-2 h-4 w-4 opacity-50" />
            </Button>
          )}
        </PopoverTrigger>
        <PopoverContent className="w-[240px] p-0" align={compact ? "end" : "start"}>
          <div className="flex flex-col">
            {modes.map((mode) => (
              <Button
                key={mode.id}
                variant="ghost"
                className={cn(
                  "flex items-center justify-between px-4 py-2 text-left",
                  currentMode === mode.id && "bg-muted"
                )}
                onClick={() => onModeChange(mode.id as ChatMode)}
              >
                <div className="flex items-center">
                  <mode.icon className="mr-2 h-4 w-4" />
                  <div>
                    <p className="text-sm font-medium">{mode.name}</p>
                    <p className="text-xs text-muted-foreground">{mode.description}</p>
                  </div>
                </div>
                {currentMode === mode.id && <Check className="h-4 w-4" />}
              </Button>
            ))}
          </div>
        </PopoverContent>
      </Popover>
    </div>
  );
}

================
File: app/dashboard/chat/history/page.tsx
================
"use client";

import { useState } from "react";
import Link from "next/link";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";

type ChatSession = {
  id: string;
  title: string;
  preview: string;
  createdAt: Date;
  updatedAt: Date;
  attachedFiles?: {
    id: number;
    name: string;
  }[];
};

// Mock data for chat history
const mockChatHistory: ChatSession[] = [
  {
    id: "chat-1",
    title: "Climate Report Discussion",
    preview: "Can you tell me more about the recommended actions in the report?",
    createdAt: new Date(Date.now() - 1000 * 60 * 60 * 2), // 2 hours ago
    updatedAt: new Date(Date.now() - 1000 * 60 * 30), // 30 minutes ago
    attachedFiles: [
      {
        id: 1,
        name: "Climate_Report_2023.pdf",
      },
    ],
  },
  {
    id: "chat-2",
    title: "Financial Statement Analysis",
    preview: "What are the key insights from this quarterly financial report?",
    createdAt: new Date(Date.now() - 1000 * 60 * 60 * 24), // 1 day ago
    updatedAt: new Date(Date.now() - 1000 * 60 * 60 * 23), // 23 hours ago
    attachedFiles: [
      {
        id: 2,
        name: "Q2_Financial_Report.pdf",
      },
    ],
  },
  {
    id: "chat-3",
    title: "Research Paper Review",
    preview: "Can you summarize the methodology section of this research paper?",
    createdAt: new Date(Date.now() - 1000 * 60 * 60 * 48), // 2 days ago
    updatedAt: new Date(Date.now() - 1000 * 60 * 60 * 47), // 47 hours ago
    attachedFiles: [
      {
        id: 3,
        name: "Machine_Learning_Research.pdf",
      },
    ],
  },
  {
    id: "chat-4",
    title: "Contract Analysis",
    preview: "What are the key terms and conditions in this contract?",
    createdAt: new Date(Date.now() - 1000 * 60 * 60 * 72), // 3 days ago
    updatedAt: new Date(Date.now() - 1000 * 60 * 60 * 70), // 70 hours ago
    attachedFiles: [
      {
        id: 4,
        name: "Service_Agreement_2023.pdf",
      },
    ],
  },
  {
    id: "chat-5",
    title: "General Questions",
    preview: "How can I extract text from a PDF programmatically?",
    createdAt: new Date(Date.now() - 1000 * 60 * 60 * 96), // 4 days ago
    updatedAt: new Date(Date.now() - 1000 * 60 * 60 * 95), // 95 hours ago
  },
];

export default function ChatHistoryPage() {
  const [searchQuery, setSearchQuery] = useState("");
  const [chatHistory, setChatHistory] = useState<ChatSession[]>(mockChatHistory);

  // Filter chat history based on search query
  const filteredChatHistory = chatHistory.filter(
    (chat) =>
      chat.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
      chat.preview.toLowerCase().includes(searchQuery.toLowerCase()) ||
      chat.attachedFiles?.some((file) =>
        file.name.toLowerCase().includes(searchQuery.toLowerCase())
      )
  );

  // Format date to relative time (e.g., "2 hours ago")
  const formatRelativeTime = (date: Date) => {
    const now = new Date();
    const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);
    
    if (diffInSeconds < 60) {
      return "just now";
    }
    
    const diffInMinutes = Math.floor(diffInSeconds / 60);
    if (diffInMinutes < 60) {
      return `${diffInMinutes} minute${diffInMinutes === 1 ? "" : "s"} ago`;
    }
    
    const diffInHours = Math.floor(diffInMinutes / 60);
    if (diffInHours < 24) {
      return `${diffInHours} hour${diffInHours === 1 ? "" : "s"} ago`;
    }
    
    const diffInDays = Math.floor(diffInHours / 24);
    if (diffInDays < 30) {
      return `${diffInDays} day${diffInDays === 1 ? "" : "s"} ago`;
    }
    
    const diffInMonths = Math.floor(diffInDays / 30);
    if (diffInMonths < 12) {
      return `${diffInMonths} month${diffInMonths === 1 ? "" : "s"} ago`;
    }
    
    const diffInYears = Math.floor(diffInMonths / 12);
    return `${diffInYears} year${diffInYears === 1 ? "" : "s"} ago`;
  };

  const deleteChat = (id: string) => {
    setChatHistory((prev) => prev.filter((chat) => chat.id !== id));
  };

  return (
    <div className="w-full max-w-6xl mx-auto py-6 px-4">
      <div className="flex items-center justify-between mb-6">
        <h1 className="text-2xl font-bold tracking-tight">Chat History</h1>
        <Link href="/dashboard/chat">
          <Button>New Chat</Button>
        </Link>
      </div>

      <div className="mb-8">
        <Input
          type="text"
          placeholder="Search conversations..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          className="max-w-md"
        />
      </div>

      {filteredChatHistory.length === 0 ? (
        <div className="text-center py-16 bg-muted/20 rounded-lg">
          <div className="inline-flex items-center justify-center w-20 h-20 rounded-full bg-muted mb-6">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
              className="h-10 w-10 text-muted-foreground"
            >
              <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" />
            </svg>
          </div>
          <h2 className="text-xl font-semibold mb-3">No conversations found</h2>
          <p className="text-muted-foreground mb-6 max-w-md mx-auto">
            {searchQuery
              ? "Try a different search term or clear your search to see all conversations"
              : "Start a new chat to begin asking questions about your PDF documents"}
          </p>
          <Link href="/dashboard/chat">
            <Button size="lg" className="px-6">Start a new chat</Button>
          </Link>
        </div>
      ) : (
        <div className="grid gap-6 sm:grid-cols-1 md:grid-cols-2 lg:grid-cols-3">
          {filteredChatHistory.map((chat) => (
            <Card key={chat.id} className="overflow-hidden hover:shadow-md transition-shadow">
              <CardHeader className="pb-2">
                <CardTitle className="truncate">{chat.title}</CardTitle>
                <CardDescription>
                  Created {formatRelativeTime(chat.createdAt)}
                </CardDescription>
              </CardHeader>
              <CardContent className="pb-2">
                <p className="text-sm text-muted-foreground line-clamp-2">
                  {chat.preview}
                </p>
                {chat.attachedFiles && chat.attachedFiles.length > 0 && (
                  <div className="mt-3 flex flex-wrap gap-2">
                    {chat.attachedFiles.map((file) => (
                      <div
                        key={file.id}
                        className="flex items-center gap-1 rounded-full bg-muted px-2 py-1 text-xs"
                      >
                        <svg
                          xmlns="http://www.w3.org/2000/svg"
                          width="24"
                          height="24"
                          viewBox="0 0 24 24"
                          fill="none"
                          stroke="currentColor"
                          strokeWidth="2"
                          strokeLinecap="round"
                          strokeLinejoin="round"
                          className="h-3 w-3"
                        >
                          <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" />
                          <polyline points="14 2 14 8 20 8" />
                        </svg>
                        <span className="truncate max-w-[100px]">{file.name}</span>
                      </div>
                    ))}
                  </div>
                )}
              </CardContent>
              <CardFooter className="flex justify-between pt-3 border-t">
                <div className="text-xs text-muted-foreground">
                  Updated {formatRelativeTime(chat.updatedAt)}
                </div>
                <div className="flex gap-2">
                  <Button
                    variant="outline"
                    size="icon"
                    className="h-8 w-8"
                    onClick={() => deleteChat(chat.id)}
                  >
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="24"
                      height="24"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      className="h-4 w-4"
                    >
                      <path d="M3 6h18" />
                      <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
                      <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
                    </svg>
                    <span className="sr-only">Delete</span>
                  </Button>
                  <Link href={`/dashboard/chat/${chat.id}`}>
                    <Button size="sm">View</Button>
                  </Link>
                </div>
              </CardFooter>
            </Card>
          ))}
        </div>
      )}
    </div>
  );
}

================
File: app/dashboard/chat/page.tsx
================
'use client';

import { useRef, useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { useChat } from 'ai/react';
import { Textarea } from '@/components/ui/textarea';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { searchDocumentsInPythonBackend } from '@/lib/python-backend';
import { queryDocumentWithLLM } from 'd:/pdverse-v3/lib/python-backend';
import { ChatModeSelector } from './components/ChatModeSelector';


type FileAttachment = {
  id: string;
  name: string;
};

export default function ChatPage() {
  const [attachedFiles, setAttachedFiles] = useState<FileAttachment[]>([]);
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [availableFiles, setAvailableFiles] = useState<FileAttachment[]>([]);
  const [isLoadingFiles, setIsLoadingFiles] = useState(false);
  const [aiModel, setAiModel] = useState("GPT-4o");
  const [chatMode, setChatMode] = useState<'document' | 'general' | 'search' | 'advanced'>('document');
  const textAreaRef = useRef<HTMLTextAreaElement>(null);

  const { messages, input, handleInputChange, isLoading, append, setInput } = useChat({
    api: '/api/chat',
    body: {
      fileIds: attachedFiles.map(file => file.id),
      chatMode: chatMode
    },
    onResponse: async (response) => {
      console.log('Raw response from useChat:', response.status);
      const data = await response.json();
      console.log('Parsed response:', data);
      
      // Only append if we're in general mode
      if (chatMode === 'general' && data?.content) {
        await append({
          id: `assistant-${Date.now()}`,
          role: 'assistant',
          content: data.content,
        });
      }
    },
    onError: (error) => {
      console.error('useChat error:', error);
    },
  });

  useEffect(() => {
    const loadAiModel = () => {
      try {
        const savedModel = localStorage.getItem("ai_model") || "gpt-4o";
        const modelDisplayNames: Record<string, string> = {
          "gpt-4o": "GPT-4o",
          "gpt-4-turbo": "GPT-4 Turbo",
          "gpt-4": "GPT-4",
          "gpt-3.5-turbo": "GPT-3.5 Turbo"
        };
        setAiModel(modelDisplayNames[savedModel] || "GPT-4o");
      } catch (error) {
        console.error("Error loading AI model setting:", error);
      }
    };
    loadAiModel();
  }, []);

  const fetchAvailableFiles = async () => {
    setIsLoadingFiles(true);
    try {
      const response = await fetch("/api/files");
      if (!response.ok) throw new Error("Failed to fetch files");
      const data = await response.json();
      if (!data?.files) {
        setAvailableFiles([]);
        return;
      }
      const files = data.files.map((file: any) => ({
        id: file.id,
        name: file.original_filename || file.filename
      }));
      setAvailableFiles(files);
    } catch (error) {
      console.error("Error fetching files:", error);
      setAvailableFiles([]);
    } finally {
      setIsLoadingFiles(false);
    }
  };

  const handleAttachFile = (file: FileAttachment) => {
    if (!attachedFiles.some(f => f.id === file.id)) {
      setAttachedFiles([...attachedFiles, file]);
    }
    setIsDialogOpen(false);
  };

  const handleRemoveFile = (fileId: string) => {
    setAttachedFiles(attachedFiles.filter(file => file.id !== fileId));
  };

  const handleMessageSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (isLoading || !input.trim()) return;

    const userMessage = input;
    setInput(''); // Clear input immediately

    // Add user message
    await append({
      role: 'user',
      content: userMessage,
    });

    try {
      if (attachedFiles.length > 0) {
        // Document mode: Direct API call
        const response = await fetch('/api/chat', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            messages: [...messages, { role: 'user', content: userMessage }],
            fileIds: attachedFiles.map(file => file.id),
            chatMode: 'document'
          }),
        });

        const data = await response.json();
        await append({
          role: 'assistant',
          content: data.content,
        });
      } else {
        // General mode: Let useChat handle it
        await append({
          role: 'user',
          content: userMessage,
        });
      }
    } catch (error) {
      console.error('Submit error:', error);
      await append({
        role: 'assistant',
        content: "Sorry, I encountered an error processing your request.",
      });
    }
  };

  const formatSearchResults = (searchResults: any) => {
    if (!searchResults || !searchResults.results || searchResults.results.length === 0) {
      return "No results found for your query.";
    }
    let formattedResponse = `### Search Results\n\nHere are the top results for your query:\n\n`;
    searchResults.results.forEach((result: any, index: number) => {
      const documentTitle = result.document_title || 'Untitled Document';
      const content = result.content || '';
      formattedResponse += `**Result ${index + 1}** (from ${documentTitle})\n`;
      formattedResponse += `${content.substring(0, 300)}${content.length > 300 ? '...' : ''}\n\n`;
    });
    formattedResponse += `Found ${searchResults.total} results in total.`;
    return formattedResponse;
  };

  return (
    <div className="flex flex-col h-[calc(100vh-4rem)]">
      <div className="w-full max-w-3xl mx-auto flex flex-col h-full relative">
        <div className={`flex-1 overflow-y-auto px-4 space-y-5 ${attachedFiles.length > 0 ? 'mb-[180px]' : 'mb-[140px]'}`}>
          {messages.map(message => (
            <div 
              key={message.id} 
              className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}
            >
              <div className="flex flex-col">
                {message.role !== 'user' && (
                  <div className="inline-flex items-center gap-1 px-2 py-0.5 rounded-full bg-muted/60 text-[10px] font-medium ml-1 mb-1 w-fit">
                    <span className="h-1 w-1 rounded-full bg-green-500"></span>
                    <span>{aiModel}</span>
                  </div>
                )}
                <div 
                  className={`max-w-[85%] rounded-lg p-3 text-sm ${
                    message.role === 'user' 
                      ? 'bg-primary text-primary-foreground' 
                      : 'bg-muted'
                  }`}
                >
                  <div className="whitespace-pre-wrap">{message.content}</div>
                </div>
              </div>
            </div>
          ))}
          {messages.length === 0 && (
            <div className="flex flex-col items-center justify-center h-full text-muted-foreground py-12">
              <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M8 9H16M8 13H14M18 15L21 18V4C21 3.46957 20.7893 2.96086 20.4142 2.58579C20.0391 2.21071 19.5304 2 19 2H5C4.46957 2 3.96086 2.21071 3.58579 2.58579C3.21071 2.96086 3 3.46957 3 4V18C3 18.5304 3.21071 19.0391 3.58579 19.4142C3.96086 19.7893 4.46957 20 5 20H18Z" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
              </svg>
              <p className="text-lg">Welcome to PDVerse Chat</p>
              <p className="text-sm text-muted-foreground mt-2">Ask any question or attach PDFs to ask about your documents</p>
            </div>
          )}
        </div>
        
        {attachedFiles.length > 0 && (
          <div className="px-4 py-3 absolute bottom-[76px] left-0 right-0 bg-background border-t">
            <div className="max-w-3xl mx-auto flex flex-wrap gap-2">
              {attachedFiles.map(file => (
                <div key={file.id} className="bg-muted px-3 py-1 rounded-full text-sm flex items-center gap-2">
                  <span className="truncate max-w-xs">{file.name}</span>
                  <button
                    type="button"
                    className="rounded-full p-1 hover:bg-muted/80"
                    onClick={() => handleRemoveFile(file.id)}
                    aria-label="Remove file"
                  >
                    <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M9 3L3 9M3 3L9 9" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"/>
                    </svg>
                  </button>
                </div>
              ))}
            </div>
          </div>
        )}
        
        <div className="px-4 pt-2 pb-4 absolute bottom-0 left-0 right-0 bg-background border-t">
          <form onSubmit={handleMessageSubmit} className="relative max-w-3xl mx-auto flex items-center gap-2">
            <ChatModeSelector 
              currentMode={chatMode}
              onModeChange={(mode) => {
                setChatMode(mode);
                if (mode !== 'document') setAttachedFiles([]);
              }}
              compact={true}
            />
            <div className="relative shadow-sm rounded-lg border border-input flex-1">
              <Textarea
                ref={textAreaRef}
                value={input}
                onChange={handleInputChange}
                placeholder={`Ask a question in ${chatMode === 'document' ? 'Document Chat' : 
                              chatMode === 'general' ? 'General Chat' : 
                              chatMode === 'search' ? 'Search Mode' : 'Advanced Analysis'} mode...`}
                className="w-full p-3 pr-12 min-h-[50px] max-h-[150px] resize-none rounded-lg border-0 focus-visible:ring-0 focus-visible:ring-offset-0"
                onKeyDown={(e) => {
                  if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    const form = e.currentTarget.closest('form');
                    if (form && !isLoading && input.trim()) {
                      form.requestSubmit();
                    }
                  }
                }}
              />
              {chatMode === 'document' && (
                <button 
                  type="button" 
                  className="absolute right-2 bottom-[10px] p-1.5 rounded-full hover:bg-muted transition-colors"
                  onClick={() => {
                    setIsDialogOpen(true);
                    fetchAvailableFiles();
                  }}
                  aria-label="Attach files"
                >
                  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21.44 11.05l-9.19 9.19a6 6 0 01-8.49-8.49l9.19-9.19a4 4 0 015.66 5.66l-9.2 9.19a2 2 0 01-2.83-2.83l8.49-8.48" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
                  </svg>
                </button>
              )}
            </div>
            <Button 
              type="submit" 
              disabled={isLoading || !input.trim()}
              className="h-10 w-10 rounded-full p-0 flex-shrink-0"
              aria-label="Send message"
            >
              {isLoading ? (
                <div className="animate-spin h-4 w-4 border-2 border-background border-t-transparent rounded-full" />
              ) : (
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M14.6667 1.33334L7.33334 8.66668M14.6667 1.33334L10 14.6667L7.33334 8.66668M14.6667 1.33334L1.33334 6.00001L7.33334 8.66668" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round"/>
                </svg>
              )}
            </Button>
          </form>
        </div>
        
        {isDialogOpen && (
          <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
            <DialogContent className="sm:max-w-md">
              <DialogHeader>
                <DialogTitle>Attach PDF Files</DialogTitle>
              </DialogHeader>
              <div className="py-4 max-h-[400px] overflow-y-auto">
                {isLoadingFiles ? (
                  <div className="flex justify-center items-center py-8">
                    <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
                  </div>
                ) : availableFiles.length > 0 ? (
                  <div className="space-y-2">
                    {availableFiles.map(file => (
                      <div 
                        key={file.id} 
                        className="flex items-center p-3 rounded-lg border border-border hover:bg-muted cursor-pointer transition-colors"
                        onClick={() => handleAttachFile(file)}
                      >
                        <div className="mr-3 text-muted-foreground">
                          <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M17.5 15.8333V17.5H2.5V15.8333H17.5ZM4.16667 3.33333H15.8333V10.8333H4.16667V3.33333ZM5.83333 5V9.16667H14.1667V5H5.83333ZM8.33333 11.6667H11.6667V14.1667H8.33333V11.6667Z" fill="currentColor"/>
                          </svg>
                        </div>
                        <div className="font-medium truncate">{file.name}</div>
                      </div>
                    ))}
                  </div>
                ) : (
                  <div className="text-center py-8 text-muted-foreground">
                    <svg className="mx-auto" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M12 2C6.48 2 2 6.48 2 12C2 17.52 6.48 22 12 22C17.52 22 22 17.52 22 12C22 6.48 17.52 2 12 2ZM12 20C7.59 20 4 16.41 4 12C4 7.59 7.59 4 12 4C16.41 4 20 7.59 20 12C20 16.41 16.41 20 12 20ZM11 15H13V17H11V15ZM11 7H13V13H11V7Z" fill="currentColor"/>
                    </svg>
                    <p>No files available. Please upload some PDFs first.</p>
                  </div>
                )}
              </div>
            </DialogContent>
          </Dialog>
        )}
      </div>
    </div>
  );
}

================
File: app/dashboard/files/[id]/page-iframe.tsx
================
import { useState, useEffect, useRef } from "react";
import { useParams, useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Card } from "@/components/ui/card";
import { formatBytes } from "@/lib/utils";
import { toast } from "sonner";
import { 
  ChevronLeft, ChevronRight, ZoomIn, ZoomOut, 
  Download, Printer, Maximize, Search, List, Wand2
} from "lucide-react";
import { Input } from "@/components/ui/input";
import { Separator } from "@/components/ui/separator";
import { Badge } from "@/components/ui/badge";

type FileDetails = {
  id: string;
  filename: string;
  path: string;
  type: string;
  size: number;
  created_at: number;
  updated_at: number;
}

type PdfMetadata = {
  title?: string;
  author?: string;
  subject?: string;
  keywords?: string;
  creator?: string;
  producer?: string;
  page_count?: number;
  creation_date?: string;
  modification_date?: string;
}

export default function FileViewPage() {
  const params = useParams();
  const router = useRouter();
  const [file, setFile] = useState<FileDetails | null>(null);
  const [metadata, setMetadata] = useState<PdfMetadata | null>(null);
  const [pageNumber, setPageNumber] = useState(1);
  const [totalPages, setTotalPages] = useState(0);
  const [scale, setScale] = useState(1.0);
  const [isLoading, setIsLoading] = useState(true);
  const [searchQuery, setSearchQuery] = useState('');
  const pdfContainerRef = useRef<HTMLDivElement>(null);
  const [isFullScreen, setIsFullScreen] = useState(false);
  const iframeRef = useRef<HTMLIFrameElement>(null);

  useEffect(() => {
    // Function to handle messages from the iframe
    const handleMessage = (event: MessageEvent) => {
      if (event.data && event.data.type === 'pdfLoaded') {
        setTotalPages(event.data.numPages);
        setIsLoading(false);
      } else if (event.data && event.data.type === 'pdfError') {
        console.error('PDF Error:', event.data.error);
        toast.error(`Error loading PDF: ${event.data.error}`);
        setIsLoading(false);
      }
    };

    // Add event listener for postMessage from iframe
    window.addEventListener('message', handleMessage);

    // Clean up
    return () => {
      window.removeEventListener('message', handleMessage);
    };
  }, []);

  // Function to generate iframe src URL
  const getIframeSrc = () => {
    if (!file) return '';
    
    // Get the absolute file URL
    const fileUrl = `${window.location.origin}${file.path}`;
    
    // Create URL to the PDF viewer with the file URL as a parameter
    return `/pdf-viewer.html?file=${encodeURIComponent(fileUrl)}`;
  };

  useEffect(() => {
    const fetchFileDetails = async () => {
      if (!params.id) return;
      
      try {
        const response = await fetch(`/api/files/${params.id}`);
        
        if (!response.ok) {
          throw new Error(`Failed to fetch file: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log("Fetched file data:", data);
        setFile(data);
        
        // If it's a PDF, also fetch metadata
        if (data.type === 'application/pdf') {
          try {
            const metadataResponse = await fetch(`/api/files/${params.id}/metadata`);
            if (metadataResponse.ok) {
              const metadataData = await metadataResponse.json();
              setMetadata(metadataData);
            }
          } catch (metadataError) {
            console.error("Failed to fetch PDF metadata:", metadataError);
          }
        }
        
        setIsLoading(false);
      } catch (error) {
        console.error("Error fetching file details:", error);
        toast.error("Failed to load file details");
        setIsLoading(false);
      }
    };
    
    fetchFileDetails();
  }, [params.id]);

  useEffect(() => {
    if (file) {
      console.log("File details:", file);
      console.log("File path:", file.path);
      // Generate absolute URL for debugging
      console.log("Absolute URL:", window.location.origin + file.path);
    }
  }, [file]);

  const goToPrevPage = () => {
    setPageNumber((prev) => Math.max(prev - 1, 1));
    // Send message to iframe to change page
    iframeRef.current?.contentWindow?.postMessage({
      type: 'changePage',
      pageNumber: pageNumber - 1
    }, '*');
  };

  const goToNextPage = () => {
    if (pageNumber < totalPages) {
      setPageNumber(pageNumber + 1);
      // Send message to iframe to change page
      iframeRef.current?.contentWindow?.postMessage({
        type: 'changePage',
        pageNumber: pageNumber + 1
      }, '*');
    }
  };

  const zoomIn = () => {
    const newScale = scale + 0.2;
    setScale(newScale);
    // Send message to iframe to zoom
    iframeRef.current?.contentWindow?.postMessage({
      type: 'zoom',
      scale: newScale
    }, '*');
  };

  const zoomOut = () => {
    const newScale = Math.max(0.5, scale - 0.2);
    setScale(newScale);
    // Send message to iframe to zoom
    iframeRef.current?.contentWindow?.postMessage({
      type: 'zoom',
      scale: newScale
    }, '*');
  };

  const handleFullScreen = () => {
    if (pdfContainerRef.current) {
      if (!document.fullscreenElement) {
        pdfContainerRef.current.requestFullscreen().catch((err) => {
          toast.error(`Error attempting to enable full-screen mode: ${err.message}`);
        });
        setIsFullScreen(true);
      } else {
        document.exitFullscreen();
        setIsFullScreen(false);
      }
    }
  };

  const handleSearch = () => {
    if (searchQuery.trim()) {
      // Send message to iframe to search
      iframeRef.current?.contentWindow?.postMessage({
        type: 'search',
        query: searchQuery
      }, '*');
    }
  };

  const downloadFile = () => {
    if (!file) return;
    
    const link = document.createElement('a');
    link.href = file.path;
    link.download = file.filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const deleteFile = async () => {
    if (!file) return;
    
    if (!window.confirm(`Are you sure you want to delete ${file.filename}?`)) {
      return;
    }
    
    try {
      const response = await fetch(`/api/files/${file.id}`, {
        method: 'DELETE',
      });
      
      if (response.ok) {
        toast.success('File deleted successfully');
        router.push('/dashboard/files');
      } else {
        throw new Error('Failed to delete file');
      }
    } catch (error) {
      console.error('Error deleting file:', error);
      toast.error('Failed to delete file');
    }
  };

  return (
    <div className="container mx-auto py-6 flex flex-col h-[calc(100vh-66px)]">
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center gap-2">
          <Button 
            variant="ghost" 
            size="icon" 
            onClick={() => router.push('/dashboard/files')}
          >
            <ChevronLeft className="h-5 w-5" />
            <span className="sr-only">Back</span>
          </Button>
          <h1 className="text-2xl font-bold">File Viewer</h1>
        </div>
        
        <div className="flex gap-2">
          <Button 
            variant="outline" 
            onClick={downloadFile}
          >
            <Download className="h-4 w-4 mr-2" />
            Download
          </Button>
          <Button 
            variant="destructive" 
            onClick={deleteFile}
          >
            Delete
          </Button>
        </div>
      </div>
      
      {isLoading ? (
        <div className="flex justify-center items-center flex-1">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
        </div>
      ) : file ? (
        <div className="flex-1">
          <Card className="flex flex-col h-full overflow-hidden">
            <div className="p-4 border-b">
              <h2 className="text-xl font-semibold truncate">
                {file.filename}
              </h2>
              <div className="text-sm text-muted-foreground">
                {formatBytes(file.size)} â¢ 
                {new Date(file.updated_at * 1000).toLocaleDateString()}
                {totalPages > 0 && ` â¢ ${totalPages} pages`}
              </div>
              {metadata?.author && (
                <Badge variant="outline" className="mr-2">
                  Author: {metadata.author}
                </Badge>
              )}
              {metadata?.title && (
                <Badge variant="outline">
                  Title: {metadata.title}
                </Badge>
              )}
            </div>
            
            {file.type === 'application/pdf' && (
              <div className="px-4 py-2 border-b flex items-center gap-4">
                <div className="flex items-center">
                  <div className="flex items-center space-x-1">
                    <Button
                      variant="outline"
                      size="icon"
                      onClick={goToPrevPage}
                      disabled={pageNumber <= 1}
                    >
                      <ChevronLeft className="h-4 w-4" />
                      <span className="sr-only">Previous page</span>
                    </Button>
                    <span className="text-sm">
                      Page {pageNumber} of {totalPages || "?"}
                    </span>
                    <Button
                      variant="outline"
                      size="icon"
                      onClick={goToNextPage}
                      disabled={pageNumber >= totalPages}
                    >
                      <ChevronRight className="h-4 w-4" />
                      <span className="sr-only">Next page</span>
                    </Button>
                  </div>
                </div>
                
                <Separator orientation="vertical" className="h-6" />
                
                <div className="flex items-center space-x-1">
                  <Button variant="outline" size="icon" onClick={zoomOut}>
                    <ZoomOut className="h-4 w-4" />
                    <span className="sr-only">Zoom out</span>
                  </Button>
                  <Button variant="outline" size="icon" onClick={zoomIn}>
                    <ZoomIn className="h-4 w-4" />
                    <span className="sr-only">Zoom in</span>
                  </Button>
                </div>
                
                <Separator orientation="vertical" className="h-6" />
                
                <div className="flex items-center space-x-1">
                  <Button variant="outline" size="icon" onClick={handleFullScreen}>
                    <Maximize className="h-4 w-4" />
                    <span className="sr-only">Full Screen</span>
                  </Button>
                </div>
              </div>
            )}
            
            <div className="flex-1 relative">
              <Input
                placeholder="Search in document..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                onKeyDown={(e) => e.key === 'Enter' && handleSearch()}
                className="absolute top-4 right-4 w-64 z-10"
              />
              
              <div 
                ref={pdfContainerRef}
                className={`flex-1 overflow-auto flex justify-center bg-accent/30 rounded-md ${isFullScreen ? 'fullscreen-pdf' : ''}`}
              >
                {file.type === 'application/pdf' ? (
                  <iframe
                    ref={iframeRef}
                    src={getIframeSrc()}
                    className="w-full h-full border-0"
                    title="PDF Viewer"
                    sandbox="allow-same-origin allow-scripts"
                  />
                ) : (
                  <div className="flex flex-col items-center justify-center h-full">
                    <div className="bg-muted p-8 rounded-lg text-center">
                      <h3 className="text-lg font-medium mb-2">Preview not available</h3>
                      <p className="text-muted-foreground mb-4">
                        This file type ({file.type}) cannot be previewed in the browser.
                      </p>
                      <Button onClick={downloadFile}>
                        <Download className="h-4 w-4 mr-2" />
                        Download to view
                      </Button>
                    </div>
                  </div>
                )}
              </div>
            </div>
          </Card>
        </div>
      ) : (
        <div className="flex justify-center items-center flex-1">
          <div className="bg-muted p-8 rounded-lg text-center">
            <h3 className="text-lg font-medium mb-2">File not found</h3>
            <p className="text-muted-foreground mb-4">
              The requested file could not be found or you don't have permission to view it.
            </p>
            <Button onClick={() => router.push('/dashboard/files')}>
              Go back to files
            </Button>
          </div>
        </div>
      )}
    </div>
  );
}

================
File: app/dashboard/files/[id]/page.tsx
================
"use client";

import { useState, useEffect, useRef } from "react";
import { useParams, useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { formatBytes } from "@/lib/utils";
import { toast } from "sonner";
import { 
  ChevronLeft, ChevronRight, ZoomIn, ZoomOut, 
  Download, Printer, Maximize, Search, List, Wand2,
  Trash2
} from "lucide-react";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { getDocumentFromPythonBackend } from "@/lib/python-backend";

type FileDetails = {
  id: string;
  filename: string;
  original_filename: string;
  size: number;
  path: string;
  mimetype: string;
  created_at: number;
  updated_at: number;
};

type PdfMetadata = {
  file_id: string;
  title?: string;
  author?: string;
  subject?: string;
  keywords?: string;
  creator?: string;
  producer?: string;
  page_count?: number;
  creation_date?: string;
  modification_date?: string;
  summary?: string;
  document_type?: string;
  topics?: string;
  ai_enhanced?: boolean;
  needs_review?: boolean;
  created_at: number;
  updated_at: number;
};

const FileMetadataSection = ({ metadata }: { metadata: any }) => {
  if (!metadata) return null;

  return (
    <div className="space-y-4">
      <Card>
        <CardHeader>
          <CardTitle>Document Summary</CardTitle>
        </CardHeader>
        <CardContent>
          <p>{metadata.summary || "No summary available"}</p>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle>Classification</CardTitle>
        </CardHeader>
        <CardContent className="space-y-2">
          <div>
            <span className="font-medium">Document Type:</span>
            <span className="ml-2">{metadata.doc_type || "Unclassified"}</span>
          </div>
          <div>
            <span className="font-medium">Key Topics:</span>
            <div className="flex flex-wrap gap-2 mt-1">
              {(metadata.topics || []).map((topic: string) => (
                <Badge key={topic} variant="outline">
                  {topic}
                </Badge>
              ))}
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Add other metadata sections as needed */}
    </div>
  );
};

export default function FileViewPage() {
  const params = useParams();
  const router = useRouter();
  const [file, setFile] = useState<FileDetails | null>(null);
  const [metadata, setMetadata] = useState<PdfMetadata | null>(null);
  const [pageNumber, setPageNumber] = useState(1);
  const [scale, setScale] = useState(1.0);
  const [isLoading, setIsLoading] = useState(true);
  const [isDeleting, setIsDeleting] = useState(false);
  const [searchText, setSearchText] = useState("");
  const [showOutline, setShowOutline] = useState(false);
  const pdfContainerRef = useRef<HTMLDivElement>(null);
  const [isFullScreen, setIsFullScreen] = useState(false);

  useEffect(() => {
    const fetchFileDetails = async () => {
      if (!params.id) return;
      
      try {
        setIsLoading(true);
        
        // Use Python backend to get document details
        try {
          const documentData = await getDocumentFromPythonBackend(params.id as string);
          
          // Convert Python backend format to our frontend format
          const fileData: FileDetails = {
            id: documentData.id,
            filename: documentData.filename,
            original_filename: documentData.title,
            size: documentData.file_size,
            path: '', // Not provided by Python backend
            mimetype: 'application/pdf',
            created_at: new Date(documentData.creation_date || Date.now()).getTime() / 1000,
            updated_at: new Date(documentData.modification_date || Date.now()).getTime() / 1000,
          };
          
          setFile(fileData);
          
          // Set metadata from Python backend
          const metadataData: PdfMetadata = {
            file_id: documentData.id,
            title: documentData.title,
            author: documentData.author,
            summary: documentData.summary,
            page_count: documentData.page_count,
            creation_date: documentData.creation_date || undefined,
            modification_date: documentData.modification_date || undefined,
            document_type: documentData.doc_type,
            topics: documentData.topics || [],
            ai_enhanced: true,
            needs_review: false,
            created_at: new Date(documentData.creation_date || Date.now()).getTime() / 1000,
            updated_at: new Date(documentData.modification_date || Date.now()).getTime() / 1000,
          };
          
          setMetadata(metadataData);
          
        } catch (error) {
          console.error("Error fetching document from Python backend:", error);
          
          // Fall back to the original method if Python backend fails
          const response = await fetch(`/api/files?id=${params.id}`);
          
          if (!response.ok) {
            throw new Error("Failed to fetch file details");
          }
          
          const data = await response.json();
          // Handle both response formats: { file: ... } or direct file object
          const fileData = data.file || data;
          setFile(fileData);
          
          // Fetch PDF metadata if available
          if (fileData && fileData.id) {
            try {
              const metadataResponse = await fetch(`/api/pdf-metadata?fileId=${fileData.id}`);
              if (metadataResponse.ok) {
                const metadataData = await metadataResponse.json();
                setMetadata(metadataData.metadata);
              }
            } catch (metadataError) {
              console.error("Error fetching PDF metadata:", metadataError);
            }
          }
        }
      } catch (error) {
        console.error("Error fetching file details:", error);
        toast.error("Failed to load file details. Please try again.");
        router.push("/dashboard/files");
      } finally {
        setIsLoading(false);
      }
    };

    fetchFileDetails();
  }, [params.id, router]);

  useEffect(() => {
    if (file) {
      console.log("PDF Viewer - file object:", file);
      console.log("PDF Viewer - trying to load file from path:", file.path);
      
      // Calculate and log the absolute URL
      const absoluteUrl = window.location.origin + file.path;
      console.log("PDF Viewer - absolute URL:", absoluteUrl);
      
      // Try to fetch the file directly to check if it's accessible
      fetch(file.path)
        .then(response => {
          console.log("PDF fetch response status:", response.status);
          return response.blob();
        })
        .then(blob => {
          console.log("PDF fetch success, content type:", blob.type);
        })
        .catch(error => {
          console.error("PDF fetch failed:", error);
        });
    }
  }, [file]);

  const goToPrevPage = () => {
    setPageNumber((prev) => Math.max(prev - 1, 1));
  };

  const goToNextPage = () => {
    setPageNumber((prev) => prev + 1);
  };

  const zoomIn = () => {
    setScale((prev) => Math.min(prev + 0.2, 3));
  };

  const zoomOut = () => {
    setScale((prev) => Math.max(prev - 0.2, 0.5));
  };

  const toggleFullScreen = () => {
    if (!pdfContainerRef.current) return;
    
    if (!document.fullscreenElement) {
      pdfContainerRef.current.requestFullscreen().catch(err => {
        toast.error(`Error attempting to enable full-screen mode: ${err.message}`);
      });
      setIsFullScreen(true);
    } else {
      document.exitFullscreen();
      setIsFullScreen(false);
    }
  };
  
  const handlePrint = () => {
    if (!file) return;
    
    const printWindow = window.open(file.path, '_blank');
    if (printWindow) {
      printWindow.onload = () => {
        printWindow.print();
      };
    }
  };
  
  const handleDownload = () => {
    if (!file) return;
    
    // Create a download link pointing directly to our API route
    const link = document.createElement('a');
    link.href = file.path;
    link.download = file.original_filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  const handleDeleteFile = async () => {
    if (!file || !window.confirm("Are you sure you want to delete this file? This action cannot be undone.")) {
      return;
    }
    
    try {
      setIsDeleting(true);
      
      const response = await fetch(`/api/files?id=${file.id}`, {
        method: 'DELETE',
      });
      if (!response.ok) throw new Error('Failed to delete file');
      
      toast.success("File deleted successfully");
      router.push("/dashboard/files");
    } catch (error) {
      console.error("Error deleting file:", error);
      toast.error("Failed to delete file. Please try again.");
      setIsDeleting(false);
    }
  };

  const enhanceMetadata = async () => {
    if (!file) return;
    
    try {
      setIsLoading(true);
      const response = await fetch('/api/enhance-metadata', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ fileId: file.id }),
      });
      
      if (!response.ok) {
        throw new Error('Failed to enhance metadata');
      }
      
      const data = await response.json();
      setMetadata(data.metadata);
      toast.success('Metadata enhanced successfully');
    } catch (error) {
      console.error('Error enhancing metadata:', error);
      toast.error('Failed to enhance metadata. Please try again.');
    } finally {
      setIsLoading(false);
    }
  };

  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-[calc(100vh-200px)]">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
      </div>
    );
  }

  if (!file) {
    return (
      <div className="flex flex-col items-center justify-center h-[calc(100vh-200px)] gap-4">
        <h3 className="text-xl font-semibold">File not found</h3>
        <p className="text-muted-foreground">
          The file you are looking for does not exist or has been deleted.
        </p>
        <Button onClick={() => router.push("/dashboard/files")}>
          Back to Files
        </Button>
      </div>
    );
  }

  return (
    <div className="flex flex-col gap-6">
      <div className="flex items-center justify-between">
        <div className="space-y-1">
          <h1 className="text-3xl font-bold tracking-tight">
            {file.original_filename}
          </h1>
          <div className="text-sm text-muted-foreground">
            {formatBytes(file.size)} â¢ 
            {new Date(file.updated_at * 1000).toLocaleDateString()}
          </div>
          {metadata?.author && (
            <Badge variant="outline" className="mr-2">
              Author: {metadata.author}
            </Badge>
          )}
        </div>
        <div className="flex items-center gap-2">
          <Button variant="outline" onClick={() => router.push("/dashboard/files")}>
            Back
          </Button>
          <Button variant="destructive" onClick={handleDeleteFile} disabled={isDeleting}>
            {isDeleting ? "Deleting..." : "Delete"}
          </Button>
        </div>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-[1fr_300px] gap-6">
        <div className="flex flex-col">
          <Card className="p-4 flex flex-col">
            <div className="flex items-center justify-between mb-4">
              <div className="flex items-center gap-2">
                <Button
                  variant="outline"
                  size="icon"
                  onClick={goToPrevPage}
                >
                  <ChevronLeft className="h-4 w-4" />
                  <span className="sr-only">Previous page</span>
                </Button>
                <span className="text-sm">
                  Page {pageNumber}
                </span>
                <Button
                  variant="outline"
                  size="icon"
                  onClick={goToNextPage}
                >
                  <ChevronRight className="h-4 w-4" />
                  <span className="sr-only">Next page</span>
                </Button>
              </div>
              <div className="flex items-center gap-2">
                <Button variant="outline" size="icon" onClick={zoomOut}>
                  <ZoomOut className="h-4 w-4" />
                  <span className="sr-only">Zoom out</span>
                </Button>
                <span className="text-sm">{Math.round(scale * 100)}%</span>
                <Button variant="outline" size="icon" onClick={zoomIn}>
                  <ZoomIn className="h-4 w-4" />
                  <span className="sr-only">Zoom in</span>
                </Button>
                <Button variant="outline" size="icon" onClick={handleDownload}>
                  <Download className="h-4 w-4" />
                  <span className="sr-only">Download</span>
                </Button>
                <Button variant="outline" size="icon" onClick={handlePrint}>
                  <Printer className="h-4 w-4" />
                  <span className="sr-only">Print</span>
                </Button>
                <Button variant="outline" size="icon" onClick={toggleFullScreen}>
                  <Maximize className="h-4 w-4" />
                  <span className="sr-only">Full Screen</span>
                </Button>
              </div>
            </div>
            
            <div className="mb-4">
              <div className="flex gap-2">
                <Input
                  type="text"
                  placeholder="Search in document..."
                  value={searchText}
                  onChange={(e) => setSearchText(e.target.value)}
                  className="max-w-sm"
                />
                <Button variant="outline" size="icon">
                  <Search className="h-4 w-4" />
                </Button>
              </div>
            </div>
            
            <div 
              ref={pdfContainerRef}
              className={`flex-1 overflow-auto flex justify-center bg-accent/30 rounded-md ${isFullScreen ? 'fullscreen-pdf' : ''}`}
            >
            </div>
          </Card>
        </div>

        <div className="space-y-6">
          <Card className="p-4">
            <h2 className="text-xl font-semibold mb-4">File Information</h2>
            <div className="space-y-4">
              <div>
                <h3 className="text-sm font-medium">Filename</h3>
                <p className="text-sm text-muted-foreground break-all">
                  {file.original_filename}
                </p>
              </div>
              <div>
                <h3 className="text-sm font-medium">Size</h3>
                <p className="text-sm text-muted-foreground">
                  {formatBytes(file.size)}
                </p>
              </div>
              <div>
                <h3 className="text-sm font-medium">Uploaded</h3>
                <p className="text-sm text-muted-foreground">
                  {new Date(file.created_at * 1000).toLocaleString()}
                </p>
              </div>
              <div>
                <h3 className="text-sm font-medium">Last Modified</h3>
                <p className="text-sm text-muted-foreground">
                  {new Date(file.updated_at * 1000).toLocaleString()}
                </p>
              </div>
              <div>
                <h3 className="text-sm font-medium">MIME Type</h3>
                <p className="text-sm text-muted-foreground">
                  {file.mimetype}
                </p>
              </div>
            </div>
          </Card>

          {metadata && (
            <Card className="p-4">
              <div className="flex justify-between items-center mb-4">
                <h2 className="text-xl font-semibold">PDF Metadata</h2>
              </div>
              <FileMetadataSection metadata={metadata} />
            </Card>
          )}
        </div>
      </div>
    </div>
  );
}

================
File: app/dashboard/files/page.tsx
================
"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { formatBytes, truncateFilename } from "@/lib/utils";
import { toast } from "sonner";
import { Input } from "@/components/ui/input";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Skeleton } from "@/components/ui/skeleton";
import { Search } from "lucide-react";
import { searchDocumentsInPythonBackend } from "@/lib/python-backend";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";

type FileItem = {
  id: string;
  filename: string;
  original_filename: string;
  size: number;
  path: string;
  mimetype: string;
  created_at: number;
  updated_at: number;
};

export default function FilesPage() {
  // Remove the unused view state
  // const [view, setView] = useState<"grid" | "list">("grid");
  const [files, setFiles] = useState<FileItem[]>([]);
  const [filteredFiles, setFilteredFiles] = useState<FileItem[]>([]);
  const [selectedFiles, setSelectedFiles] = useState<string[]>([]);
  const [loading, setLoading] = useState(true);
  const [isSearching, setIsSearching] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [activeTab, setActiveTab] = useState<"files" | "fulltext">("files");
  const [fulltextResults, setFulltextResults] = useState<Array<{
    chunk: {
      id: string;
      documentId: string;
      pageNumber: number;
      chunkIndex: number;
      content: string;
      contentType: string;
    },
    fileInfo: {
      id: string;
      filename: string;
      original_filename: string;
      author: string;
    },
    score: number
  }>>([]);
  const [fulltextLoading, setFulltextLoading] = useState(false);
  const [searchType, setSearchType] = useState<'hybrid' | 'vector' | 'fulltext'>('hybrid');

  // Fetch files from API
  // Update the useEffect hook that fetches files
  // Fetch files from API
  useEffect(() => {
    const fetchFiles = async () => {
      setLoading(true);
      try {
        const response = await fetch('/api/files');
        
        if (!response.ok) {
          throw new Error(`Failed to fetch files: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        // Handle the response format from the Python backend
        const filesData = data.files || [];
        
        // Map the Python backend format to our frontend format
        const mappedFiles = filesData.map((doc: any) => ({
          id: doc.id,
          filename: doc.filename || doc.title,
          original_filename: doc.title,
          size: doc.file_size || 0,
          mimetype: 'application/pdf', // Assuming all files are PDFs
          created_at: new Date(doc.creation_date || Date.now()).getTime() / 1000,
          updated_at: new Date(doc.modification_date || Date.now()).getTime() / 1000,
        }));
        
        setFiles(mappedFiles);
        setFilteredFiles(mappedFiles); // Also set filtered files initially
      } catch (error) {
        console.error('Error fetching files:', error);
        toast.error('Failed to load files. Please try again.');
      } finally {
        setLoading(false);
      }
    };
    
    // Call the fetchFiles function
    fetchFiles();
  }, []);
  useEffect(() => {
    if (!searchQuery) {
      setIsSearching(false);
      setFilteredFiles(files);
      return;
    }

    // Add a small delay to show the searching state
    setIsSearching(true);
    const searchTimeout = setTimeout(() => {
      const query = searchQuery.toLowerCase();
      const filtered = files.filter((file) => {
        // Search in filename
        if (file.original_filename.toLowerCase().includes(query)) {
          return true;
        }
        // Search in system filename
        if (file.filename.toLowerCase().includes(query)) {
          return true;
        }
        // Search in mimetype
        if (file.mimetype.toLowerCase().includes(query)) {
          return true;
        }
        
        return false;
      });
      
      setFilteredFiles(filtered);
      setIsSearching(false);
    }, 300);

    return () => clearTimeout(searchTimeout);
  }, [files, searchQuery]);

  const toggleFileSelection = (id: string) => {
    setSelectedFiles((prev) =>
      prev.includes(id) ? prev.filter((fileId) => fileId !== id) : [...prev, id]
    );
  };

  const selectAllFiles = () => {
    if (selectedFiles.length === filteredFiles.length) {
      setSelectedFiles([]);
    } else {
      setSelectedFiles(filteredFiles.map((file) => file.id));
    }
  };

  const deleteSelectedFiles = async () => {
    if (selectedFiles.length === 0) return;
    
    try {
      // Delete each selected file
      for (const fileId of selectedFiles) {
        const response = await fetch(`/api/files?id=${fileId}`, {
          method: "DELETE",
        });
        
        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || "Failed to delete file");
        }
      }
      
      // Update local state
      setFiles((prev) => prev.filter((file) => !selectedFiles.includes(file.id)));
      setSelectedFiles([]);
      
      toast.success(`${selectedFiles.length} file(s) deleted successfully`);
    } catch (error) {
      console.error("Error deleting files:", error);
      toast.error("Failed to delete some files. Please try again.");
    }
  };

  

  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const query = e.target.value;
    setSearchQuery(query);
    
    if (activeTab === "files") {
      if (query.trim() === "") {
        setIsSearching(false);
        setFilteredFiles(files);
      } else {
        setIsSearching(true);
        const filtered = files.filter((file) =>
          file.original_filename.toLowerCase().includes(query.toLowerCase())
        );
        setFilteredFiles(filtered);
      }
    }
  };

  const handleFullTextSearch = async () => {
    if (!searchQuery.trim()) {
      return;
    }

    try {
      setFulltextLoading(true);
      setFulltextResults([]);

      const searchResults = await searchDocumentsInPythonBackend(searchQuery, {
        limit: 20,
        search_type: searchType, // Updated to snake_case
        vector_weight: 0.7,
        text_weight: 0.3,
      });

      const transformedResults = searchResults.results.map((result: any) => ({
        chunk: {
          id: result.chunk_id,
          documentId: result.document_id,
          pageNumber: result.page_number || 1,
          chunkIndex: 0,
          content: result.content,
          contentType: 'text',
        },
        fileInfo: {
          id: result.document_id,
          filename: result.document_info?.title || 'Unknown',
          original_filename: result.document_info?.title || 'Unknown',
          author: result.document_info?.author || 'Unknown',
        },
        score: result.score,
      }));

      setFulltextResults(transformedResults);
    } catch (error: any) {
      console.error("Error searching content:", error);
      toast.error(`Failed to search document content: ${error.message}`);
    } finally {
      setFulltextLoading(false);
    }
  };

  const handleTabChange = (value: string) => {
    setActiveTab(value as "files" | "fulltext");
    if (value === "fulltext" && searchQuery.trim()) {
      handleFullTextSearch();
    }
  };

  const handleSearchKeyDown = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter") {
      if (activeTab === "fulltext") {
        handleFullTextSearch();
      }
    }
  };

  const displayedFiles = isSearching ? filteredFiles : files;

  return (
    <div className="w-full max-w-6xl mx-auto px-4 py-6">
      <div className="flex flex-col-reverse sm:flex-row items-start sm:items-center justify-between mb-6">
        <div className="flex flex-col gap-1">
          <div className="flex items-center gap-2">
            <h1 className="text-2xl font-bold tracking-tight">Your Files</h1>
            {searchQuery && (
              <div className="flex items-center bg-accent/50 rounded-full px-3 py-1 text-sm gap-1">
                <span>Search: {searchQuery}</span>
                {isSearching && (
                  <div className="w-3 h-3 rounded-full border-t-2 border-primary animate-spin mr-1"></div>
                )}
                <button 
                  onClick={() => setSearchQuery("")}
                  className="hover:text-primary"
                  aria-label="Clear search"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="w-4 h-4">
                    <path d="M18 6 6 18"></path>
                    <path d="m6 6 12 12"></path>
                  </svg>
                </button>
              </div>
            )}
          </div>
        </div>
      </div>

      <Tabs defaultValue="files" onValueChange={handleTabChange} className="mb-8">
        <TabsList className="mb-4">
          <TabsTrigger value="files">Files</TabsTrigger>
          <TabsTrigger value="fulltext">Search</TabsTrigger>
        </TabsList>

        <div className="flex items-center mb-6 space-x-2">
          <div className="relative flex-1">
            <div className="flex gap-2 mb-4">
              <Input
                type="text"
                placeholder="Search documents..."
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
                onKeyDown={handleSearchKeyDown}
                className="flex-1"
              />
              <Select value={searchType} onValueChange={(value: 'hybrid' | 'vector' | 'fulltext') => setSearchType(value)}>
                <SelectTrigger className="w-[180px]">
                  <SelectValue placeholder="Search type" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="fulltext">Full-Text Search</SelectItem>
                  <SelectItem value="vector">Semantic Search</SelectItem>
                  <SelectItem value="hybrid">Hybrid Search</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>
          {activeTab === "fulltext" && (
            <Button 
              onClick={handleFullTextSearch} 
              disabled={fulltextLoading || !searchQuery.trim()}
            >
              {fulltextLoading ? "Searching..." : "Search"}
            </Button>
          )}
        </div>

        <TabsContent value="files">
          {loading ? (
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
              {[...Array(8)].map((_, index) => (
                <Card key={index} className="overflow-hidden hover:shadow-md transition-shadow">
                  <CardContent className="p-0">
                    <div className="relative">
                      <div className="absolute top-2 right-2 z-10">
                        <Button
                          variant="outline"
                          size="icon"
                          className="h-7 w-7 bg-background/80 backdrop-blur-sm"
                        >
                          <svg
                            xmlns="http://www.w3.org/2000/svg"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                            strokeWidth="2"
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            className="h-4 w-4"
                          >
                            <polyline points="20 6 9 17 4 12" />
                          </svg>
                        </Button>
                      </div>
                      <div className="aspect-[3/4] bg-accent/50 flex items-center justify-center">
                        <Skeleton className="h-16 w-16" />
                      </div>
                      <div className="p-4 border-t">
                        <Skeleton className="h-4 w-1/3 mb-2" />
                        <Skeleton className="h-4 w-1/4" />
                      </div>
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          ) : displayedFiles.length === 0 ? (
            <div className="text-center py-16 bg-muted/20 rounded-lg">
              <div className="inline-flex items-center justify-center w-20 h-20 rounded-full bg-muted mb-6">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  className="h-10 w-10 text-muted-foreground"
                >
                  <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" />
                  <polyline points="14 2 14 8 20 8" />
                </svg>
              </div>
              <h2 className="text-xl font-semibold mb-3">No files found</h2>
              <p className="text-muted-foreground mb-6 max-w-md mx-auto">
                {searchQuery.trim()
                  ? "No files matching your search. Try a different query."
                  : "No files uploaded yet. Upload your first PDF to get started."}
              </p>
            </div>
          ) : (
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
              {displayedFiles.map((file) => (
                <Card
                  key={file.id}
                  className={`overflow-hidden hover:shadow-md transition-shadow ${
                    selectedFiles.includes(file.id) ? "ring-2 ring-primary" : ""
                  }`}
                >
                  <CardContent className="p-0">
                    <div className="relative">
                      <div className="absolute top-2 right-2 z-10">
                        <Button
                          variant="outline"
                          size="icon"
                          className="h-7 w-7 bg-background/80 backdrop-blur-sm"
                          onClick={(e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            toggleFileSelection(file.id);
                          }}
                        >
                          {selectedFiles.includes(file.id) ? (
                            <svg
                              xmlns="http://www.w3.org/2000/svg"
                              viewBox="0 0 24 24"
                              fill="none"
                              stroke="currentColor"
                              strokeWidth="2"
                              strokeLinecap="round"
                              strokeLinejoin="round"
                              className="h-4 w-4"
                            >
                              <polyline points="20 6 9 17 4 12" />
                            </svg>
                          ) : (
                            <svg
                              xmlns="http://www.w3.org/2000/svg"
                              viewBox="0 0 24 24"
                              fill="none"
                              stroke="currentColor"
                              strokeWidth="2"
                              strokeLinecap="round"
                              strokeLinejoin="round"
                              className="h-4 w-4"
                            >
                              <rect width="18" height="18" x="3" y="3" rx="2" />
                            </svg>
                          )}
                        </Button>
                      </div>
                      <Link href={`/dashboard/files/${file.id}`}>
                        <div className="aspect-[3/4] bg-accent/50 flex items-center justify-center">
                          <svg
                            xmlns="http://www.w3.org/2000/svg"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                            strokeWidth="2"
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            className="h-16 w-16 text-muted-foreground"
                          >
                            <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" />
                            <polyline points="14 2 14 8 20 8" />
                          </svg>
                        </div>
                        <div className="p-4 border-t">
                          <div className="font-medium truncate">
                            {truncateFilename(file.original_filename)}
                          </div>
                          <div className="text-xs text-muted-foreground mt-2 flex justify-between">
                            <span>{formatBytes(file.size)}</span>
                            <span>{new Date(file.updated_at * 1000).toLocaleDateString()}</span>
                          </div>
                        </div>
                      </Link>
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          )}
        </TabsContent>

        <TabsContent value="fulltext">
          {fulltextLoading ? (
            <div className="space-y-4">
              {[...Array(3)].map((_, index) => (
                <Card key={index} className="overflow-hidden hover:shadow-md transition-shadow">
                  <CardContent className="p-0">
                    <div className="relative">
                      <div className="p-4 border-t">
                        <Skeleton className="h-4 w-1/3 mb-2" />
                        <Skeleton className="h-16 w-full mb-2" />
                        <Skeleton className="h-4 w-1/4" />
                      </div>
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          ) : fulltextResults.length === 0 ? (
            <div className="text-center py-16 bg-muted/20 rounded-lg">
              <p className="text-muted-foreground mb-6 max-w-md mx-auto">
                {searchQuery.trim() 
                  ? "No search results found. Try a different query."
                  : "Enter a search term to find content in your documents."}
              </p>
            </div>
          ) : (
            <div className="space-y-4">
              {fulltextResults.map((result, index) => (
                <Card key={index} className="overflow-hidden hover:shadow-md transition-shadow">
                  <CardContent className="p-0">
                    <div className="relative">
                      <div className="p-4 border-t">
                        <div className="mb-2">
                          <Link 
                            href={`/dashboard/files/${result.fileInfo.id}`}
                            className="text-primary font-medium hover:underline"
                          >
                            {result.fileInfo.original_filename}
                          </Link>
                          <div className="flex justify-between items-center">
                            <div className="flex gap-2">
                              <p className="text-xs text-muted-foreground">
                                {result.fileInfo.author} â¢ Page {result.chunk.pageNumber + 1}
                              </p>
                              <span className="text-xs px-2 py-1 bg-blue-100 text-blue-800 rounded-full">
                                {searchType === 'hybrid' ? 'Hybrid' : 
                                 searchType === 'vector' ? 'Semantic' : 'Text'}
                              </span>
                            </div>
                            <div className="text-xs font-medium text-green-600">
                              {typeof result.score === 'number' ? 
                               `${(result.score * 100).toFixed(1)}% Match` : 
                               result.score}
                            </div>
                          </div>
                        </div>
                        <p className="text-sm">
                          {highlightSearchTerm(result.chunk.content, searchQuery)}
                        </p>
                        <div className="mt-2 flex justify-end">
                          <Button 
                            variant="outline" 
                            size="sm"
                            asChild
                          >
                            <Link href={`/dashboard/files/${result.fileInfo.id}?page=${result.chunk.pageNumber + 1}`}>
                              View in Document
                            </Link>
                          </Button>
                        </div>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          )}
        </TabsContent>
      </Tabs>

      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <Button
            variant="outline"
            size="sm"
            onClick={selectAllFiles}
          >
            {selectedFiles.length === filteredFiles.length && filteredFiles.length > 0
              ? "Deselect All"
              : "Select All"}
          </Button>
          {selectedFiles.length > 0 && (
            <Button
              variant="destructive"
              size="sm"
              onClick={deleteSelectedFiles}
            >
              Delete Selected
            </Button>
          )}
        </div>
        <div className="text-sm text-muted-foreground">
          {filteredFiles.length} {filteredFiles.length === 1 ? "file" : "files"}
        </div>
      </div>
    </div>
  );
}

// Helper function to highlight search terms in text
function highlightSearchTerm(text: string, query: string): React.ReactNode {
  if (!query.trim()) return text;
  
  const parts = text.split(new RegExp(`(${query})`, 'gi'));
  
  return (
    <>
      {parts.map((part, i) => 
        part.toLowerCase() === query.toLowerCase() 
          ? <mark key={i} className="bg-yellow-200 dark:bg-yellow-800">{part}</mark> 
          : part
      )}
    </>
  );
}

================
File: app/dashboard/files/upload/page.tsx
================
"use client";

import { useState, useCallback } from "react";
import { useRouter } from "next/navigation";
import { useDropzone } from "react-dropzone";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { formatBytes, isValidPdf } from "@/lib/utils";
import { toast } from "sonner";
import { uploadFileToPythonBackend } from "@/lib/python-backend";

type UploadFile = {
  id: string;
  file: File;
  progress: number;
  error?: string;
  status: "pending" | "uploading" | "success" | "error";
};

export default function UploadPage() {
  const router = useRouter();
  const [files, setFiles] = useState<UploadFile[]>([]);

  const onDrop = useCallback((acceptedFiles: File[]) => {
    const newFiles = acceptedFiles
      .filter((file) => isValidPdf(file))
      .map((file) => ({
        id: Math.random().toString(36).substring(2, 15),
        file,
        progress: 0,
        status: "pending" as const,
      }));

    if (newFiles.length !== acceptedFiles.length) {
      toast.error("Some files were rejected. Only PDF files are allowed.");
    }

    setFiles((prev) => [...prev, ...newFiles]);
  }, []);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      "application/pdf": [".pdf"],
    },
  });

  const removeFile = (id: string) => {
    setFiles((prev) => prev.filter((file) => file.id !== id));
  };

  const uploadFiles = async () => {
    try {
      const formData = new FormData();
      files.forEach(fileItem => {
        formData.append("file", fileItem.file);
      });

      const response = await fetch("/api/upload", {
        method: "POST",
        body: formData,
      });
      
      const result = await response.json();
      
      if (!result.success) {
        throw new Error(result.error || 'Upload failed');
      }

      toast.success("Files uploaded successfully");
      router.push("/dashboard/files");
    } catch (error) {
      toast.error(error instanceof Error ? error.message : "File processing failed");
    }
  };

  const cancelUpload = () => {
    setFiles([]);
  };

  return (
    <div className="flex flex-col gap-6">
      <div className="flex items-center justify-between">
        <h1 className="text-3xl font-bold tracking-tight">Upload PDF Files</h1>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Upload Files</CardTitle>
        </CardHeader>
        <CardContent className="space-y-6">
          <div
            {...getRootProps()}
            className={`border-2 border-dashed rounded-lg p-12 text-center cursor-pointer transition-colors ${
              isDragActive
                ? "border-primary bg-primary/5"
                : "border-muted-foreground/25 hover:border-primary/50 hover:bg-primary/5"
            }`}
          >
            <input {...getInputProps()} />
            <div className="flex flex-col items-center gap-2">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="h-10 w-10 text-muted-foreground"
              >
                <path d="M7 16.3c2.2 0 4-1.83 4-4.05 0-1.16-.57-2.26-1.71-3.19S7.29 6.75 7 5.3c-.29 1.45-1.14 2.84-2.29 3.76S3 11.1 3 12.25c0 2.22 1.8 4.05 4 4.05z" />
                <path d="M12.56 6.6A6 6 0 0 0 16 17.88" />
                <path d="M17 20.25a6 6 0 0 0 .24-11.88" />
              </svg>
              <div>
                <p className="text-base font-medium">
                  {isDragActive
                    ? "Drop your PDF files here"
                    : "Drag & drop your PDF files here"}
                </p>
                <p className="text-sm text-muted-foreground">
                  or click to browse files
                </p>
              </div>
            </div>
          </div>

          {files.length > 0 && (
            <div className="space-y-4">
              <div className="text-sm font-medium">
                {files.length} file{files.length !== 1 ? "s" : ""} selected
              </div>
              <div className="space-y-2">
                {files.map((file) => (
                  <div
                    key={file.id}
                    className="flex items-center gap-4 rounded-lg border p-4"
                  >
                    <div className="flex h-10 w-10 items-center justify-center rounded-md bg-primary/10">
                      <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="24"
                        height="24"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        className="h-5 w-5 text-primary"
                      >
                        <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" />
                        <polyline points="14 2 14 8 20 8" />
                      </svg>
                    </div>
                    <div className="flex-1 space-y-1">
                      <div className="flex items-center justify-between">
                        <p className="text-sm font-medium">{file.file.name}</p>
                        {file.status === "pending" && (
                          <Button
                            variant="ghost"
                            size="icon"
                            onClick={() => removeFile(file.id)}
                          >
                            <svg
                              xmlns="http://www.w3.org/2000/svg"
                              width="24"
                              height="24"
                              viewBox="0 0 24 24"
                              fill="none"
                              stroke="currentColor"
                              strokeWidth="2"
                              strokeLinecap="round"
                              strokeLinejoin="round"
                              className="h-4 w-4"
                            >
                              <path d="M18 6 6 18" />
                              <path d="m6 6 12 12" />
                            </svg>
                            <span className="sr-only">Remove</span>
                          </Button>
                        )}
                        {file.status === "success" && (
                          <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="24"
                            height="24"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                            strokeWidth="2"
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            className="h-5 w-5 text-green-500"
                          >
                            <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" />
                            <polyline points="22 4 12 14.01 9 11.01" />
                          </svg>
                        )}
                        {file.status === "error" && (
                          <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="24"
                            height="24"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                            strokeWidth="2"
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            className="h-5 w-5 text-red-500"
                          >
                            <circle cx="12" cy="12" r="10" />
                            <line x1="12" x2="12" y1="8" y2="12" />
                            <line x1="12" x2="12.01" y1="16" y2="16" />
                          </svg>
                        )}
                      </div>
                      <div className="flex items-center text-xs text-muted-foreground">
                        <span>{formatBytes(file.file.size)}</span>
                      </div>
                      {(file.status === "uploading" || file.status === "success") && (
                        <div className="h-2 w-full overflow-hidden rounded-full bg-muted">
                          <div
                            className={`h-full ${
                              file.status === "success"
                                ? "bg-green-500"
                                : "bg-primary"
                            }`}
                            style={{ width: `${file.progress}%` }}
                          />
                        </div>
                      )}
                      {file.error && (
                        <p className="text-xs text-red-500">{file.error}</p>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}
        </CardContent>
        <CardFooter className="flex justify-between">
          <Button
            variant="outline"
            onClick={() => router.push("/dashboard/files")}
          >
            Cancel
          </Button>
          <div className="flex gap-2">
            {files.length > 0 && files.some(f => f.status === "pending") && (
              <Button onClick={uploadFiles}>
                Upload {files.length} file{files.length !== 1 ? "s" : ""}
              </Button>
            )}
            {files.length > 0 && files.every(f => f.status === "success") && (
              <Button onClick={() => router.push("/dashboard/files")}>
                Go to Files
              </Button>
            )}
          </div>
        </CardFooter>
      </Card>
    </div>
  );
}

================
File: app/dashboard/layout.tsx
================
'use client';

import { useState } from "react";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { Button } from "@/components/ui/button";
import AnimatedSidebarButton from "@/components/animated-sidebar-button";
import { ThemeToggle } from "@/components/theme-toggle";

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const pathname = usePathname();

  const toggleSidebar = () => {
    setSidebarOpen(!sidebarOpen);
  };

  const navigation = [
    {
      name: "Dashboard",
      href: "/dashboard",
      icon: (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className="h-4 w-4"
        >
          <rect width="7" height="9" x="3" y="3" rx="1" />
          <rect width="7" height="5" x="14" y="3" rx="1" />
          <rect width="7" height="9" x="14" y="12" rx="1" />
          <rect width="7" height="5" x="3" y="16" rx="1" />
        </svg>
      ),
    },
    {
      name: "Files",
      href: "/dashboard/files",
      icon: (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className="h-4 w-4"
        >
          <path d="M15.5 2H8.6c-.4 0-.8.2-1.1.5-.3.3-.5.7-.5 1.1v12.8c0 .4.2.8.5 1.1.3.3.7.5 1.1.5h9.8c.4 0 .8-.2 1.1-.5.3-.3.5-.7.5-1.1V6.5L15.5 2z" />
          <path d="M3 7.6v12.8c0 .4.2.8.5 1.1.3.3.7.5 1.1.5h9.8" />
          <path d="M15 2v5h5" />
        </svg>
      ),
    },
  ];

  const chatNavigation = [
    {
      name: "Chat",
      href: "/dashboard/chat",
      icon: (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className="h-4 w-4"
        >
          <path d="M14 9a2 2 0 0 1-2 2H6l-4 4V4c0-1.1.9-2 2-2h8a2 2 0 0 1 2 2v5Z" />
          <path d="M18 9h2a2 2 0 0 1 2 2v11l-4-4h-6a2 2 0 0 1-2-2v-1" />
        </svg>
      ),
      subItems: [
        {
          name: "New Chat",
          href: "/dashboard/chat",
        },
        {
          name: "Chat History",
          href: "/dashboard/chat/history",
        },
      ],
    },
  ];

  const settingsNavigation = [
    {
      name: "Settings",
      href: "/dashboard/settings",
      icon: (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className="h-4 w-4"
        >
          <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" />
          <circle cx="12" cy="12" r="3" />
        </svg>
      ),
    },
  ];

  // Check if we're on the chat page
  const isChatPage = pathname.includes('/dashboard/chat');

  return (
    <div className="flex min-h-screen w-full flex-col bg-muted/40">
      <div className="flex flex-1">
        {/* Sidebar */}
        <aside
          className={`${
            sidebarOpen ? "w-64" : "w-0 lg:w-16"
          } fixed inset-y-0 z-10 flex flex-col border-r bg-background transition-all duration-300 ease-in-out lg:relative lg:translate-x-0`}
        >
          <div className={`border-b px-4 py-4 ${!sidebarOpen && "lg:justify-center"} flex items-center relative`}>
            <div className={`flex items-center gap-2 ${!sidebarOpen && "lg:hidden"}`}>
              <div className="flex-1 flex items-center justify-between">
                <Link
                  href="/dashboard"
                  className="text-xl font-bold tracking-tight"
                >
                  PDVerse
                </Link>
              </div>
            </div>
            {/* No logo for collapsed sidebar */}
            <div className={`${sidebarOpen ? "lg:hidden" : "hidden"} hidden`}>
              <h1 className="text-lg font-semibold">PD</h1>
            </div>
          </div>
          <div className={`flex-1 overflow-auto py-2 ${!sidebarOpen && "lg:hidden"}`}>
            <nav className="grid items-start px-2 text-sm font-medium">
              <div className="px-2 py-2 text-xs font-semibold tracking-wide text-muted-foreground">
                NAVIGATION
              </div>
              <div className="grid gap-1">
                {navigation.map((item) => (
                  <Link
                    key={item.name}
                    href={item.href}
                    className={`flex items-center gap-3 rounded-lg px-3 py-2 text-muted-foreground transition-all hover:text-foreground ${
                      pathname === item.href ? "bg-muted text-foreground" : ""
                    }`}
                  >
                    {item.icon}
                    {item.name}
                  </Link>
                ))}
              </div>
              <div className="space-y-1 mt-4">
                {chatNavigation.map((item) => (
                  <div key={item.name}>
                    <Link
                      href={item.href}
                      className={`flex items-center gap-3 rounded-lg px-3 py-2 text-muted-foreground transition-all hover:text-foreground ${
                        pathname === item.href ? "bg-muted text-foreground" : ""
                      }`}
                    >
                      {item.icon}
                      {item.name}
                    </Link>
                    {item.subItems && (
                      <div className="ml-6 mt-1 space-y-1">
                        {item.subItems.map((subItem) => (
                          <Link
                            key={subItem.name}
                            href={subItem.href}
                            className={`block rounded-lg px-3 py-2 text-muted-foreground transition-all hover:text-foreground ${
                              pathname === subItem.href
                                ? "bg-muted text-foreground"
                                : ""
                            }`}
                          >
                            {subItem.name}
                          </Link>
                        ))}
                      </div>
                    )}
                  </div>
                ))}
              </div>
              <div className="mt-4 space-y-1">
                {settingsNavigation.map((item) => (
                  <Link
                    key={item.name}
                    href={item.href}
                    className={`flex items-center gap-3 rounded-lg px-3 py-2 text-muted-foreground transition-all hover:text-foreground ${
                      pathname === item.href ? "bg-muted text-foreground" : ""
                    }`}
                  >
                    {item.icon}
                    {item.name}
                  </Link>
                ))}
              </div>
            </nav>
          </div>
          {/* Collapsed sidebar navigation (only icons) */}
          <div className={`${sidebarOpen && "lg:hidden"} hidden lg:flex flex-col items-center py-4`}>
            {navigation.map((item) => (
              <Link
                key={item.name}
                href={item.href}
                className={`flex items-center justify-center w-10 h-10 my-1 rounded-lg text-muted-foreground transition-all hover:text-foreground ${
                  pathname === item.href ? "bg-muted text-foreground" : ""
                }`}
                title={item.name}
              >
                {item.icon}
              </Link>
            ))}
            
            {/* Chat navigation in collapsed mode */}
            {chatNavigation.map((item) => (
              <Link
                key={item.name}
                href={item.href}
                className={`flex items-center justify-center w-10 h-10 my-1 rounded-lg text-muted-foreground transition-all hover:text-foreground ${
                  pathname.startsWith(item.href) ? "bg-muted text-foreground" : ""
                }`}
                title={item.name}
              >
                {item.icon}
              </Link>
            ))}
            
            {/* Settings navigation in collapsed mode */}
            {settingsNavigation.map((item) => (
              <Link
                key={item.name}
                href={item.href}
                className={`flex items-center justify-center w-10 h-10 my-1 rounded-lg text-muted-foreground transition-all hover:text-foreground ${
                  pathname === item.href ? "bg-muted text-foreground" : ""
                }`}
                title={item.name}
              >
                {item.icon}
              </Link>
            ))}
          </div>
          {/* User section in sidebar */}
          <div className={`${!sidebarOpen && "lg:hidden"} mt-auto border-t p-4`}>
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <div className="h-8 w-8 rounded-full bg-muted"></div>
                <div>
                  <div className="font-medium">John Doe</div>
                  <span className="text-xs text-muted-foreground">john@example.com</span>
                </div>
              </div>
              {/* Add theme toggle in desktop user section */}
              <ThemeToggle />
            </div>
          </div>
          {/* User section - collapsed sidebar */}
          <div className={`${sidebarOpen && "lg:hidden"} hidden lg:flex flex-col border-t p-4 items-center justify-center gap-4`}>
            <div className="h-8 w-8 rounded-full bg-muted" title="John Doe"></div>
            <ThemeToggle />
          </div>
        </aside>
        {/* Main content */}
        <div className="flex flex-1 flex-col overflow-hidden">
          <header className="sticky top-0 z-30 flex h-16 items-center gap-4 border-b bg-background px-4 sm:px-6 lg:hidden">
            <AnimatedSidebarButton
              isOpen={sidebarOpen}
              onClick={toggleSidebar}
              // Remove the className prop as it's not defined in AnimatedSidebarButtonProps
            />
            <div className="flex-1 flex items-center justify-between">
              <Link
                href="/dashboard"
                className="text-lg font-semibold tracking-tight"
              >
                PDVerse
              </Link>
              <ThemeToggle />
            </div>
          </header>
          <main className={`flex-1 overflow-hidden ${isChatPage ? 'p-0' : 'p-4 lg:p-6'}`}>
            {/* Sidebar toggle button - always visible on desktop */}
            <div className={`${isChatPage ? 'p-4 pt-4' : 'mb-4'} hidden lg:flex`}>
              <AnimatedSidebarButton
                isOpen={sidebarOpen}
                onClick={toggleSidebar}
                // Remove the className prop here as well
              />
            </div>
            {children}
          </main>
        </div>
      </div>
    </div>
  );
}

================
File: app/dashboard/layout.tsx.fix
================
'use client';

import { useState } from "react";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { Button } from "@/components/ui/button";

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const pathname = usePathname();
  
  // Check if we're on the chat page
  const isChatPage = pathname.includes('/dashboard/chat');

  const toggleSidebar = () => {
    setSidebarOpen(!sidebarOpen);
  };

  const navigation = [
    {
      name: "Dashboard",
      href: "/dashboard",
      icon: (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className="h-4 w-4"
        >
          <rect width="7" height="9" x="3" y="3" rx="1" />
          <rect width="7" height="5" x="14" y="3" rx="1" />
          <rect width="7" height="9" x="14" y="12" rx="1" />
          <rect width="7" height="5" x="3" y="16" rx="1" />
        </svg>
      ),
    },
    {
      name: "Files",
      href: "/dashboard/files",
      icon: (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className="h-4 w-4"
        >
          <path d="M15.5 2H8.6c-.4 0-.8.2-1.1.5-.3.3-.5.7-.5 1.1v12.8c0 .4.2.8.5 1.1.3.3.7.5 1.1.5h9.8c.4 0 .8-.2 1.1-.5.3-.3.5-.7.5-1.1V6.5L15.5 2z" />
          <path d="M3 7.6v12.8c0 .4.2.8.5 1.1.3.3.7.5 1.1.5h9.8" />
          <path d="M15 2v5h5" />
        </svg>
      ),
    },
  ];

  const chatNavigation = [
    {
      name: "Chat",
      href: "/dashboard/chat",
      icon: (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className="h-4 w-4"
        >
          <path d="M14 9a2 2 0 0 1-2 2H6l-4 4V4c0-1.1.9-2 2-2h8a2 2 0 0 1 2 2v5Z" />
          <path d="M18 9h2a2 2 0 0 1 2 2v11l-4-4h-6a2 2 0 0 1-2-2v-1" />
        </svg>
      ),
      subItems: [
        {
          name: "New Chat",
          href: "/dashboard/chat",
        },
        {
          name: "Chat History",
          href: "/dashboard/chat/history",
        },
      ],
    },
  ];

  const settingsNavigation = [
    {
      name: "Settings",
      href: "/dashboard/settings",
      icon: (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className="h-4 w-4"
        >
          <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" />
          <circle cx="12" cy="12" r="3" />
        </svg>
      ),
    },
  ];

  return (
    <div className="flex min-h-screen w-full flex-col bg-muted/40">
      <div className="flex flex-1">
        {/* Sidebar */}
        <aside
          className={`${
            sidebarOpen ? "w-64" : "w-0 -translate-x-full"
          } fixed inset-y-0 z-10 flex flex-col border-r bg-background transition-all lg:relative lg:translate-x-0`}
        >
          <div className="border-b px-4 py-4">
            <div className="flex items-center gap-2">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="h-6 w-6"
              >
                <path d="M5 3a2 2 0 0 0-2 2" />
                <path d="M19 3a2 2 0 0 1 2 2" />
                <path d="M21 19a2 2 0 0 1-2 2" />
                <path d="M5 21a2 2 0 0 1-2-2" />
                <path d="M9 3h1" />
                <path d="M9 21h1" />
                <path d="M14 3h1" />
                <path d="M14 21h1" />
                <path d="M3 9v1" />
                <path d="M21 9v1" />
                <path d="M3 14v1" />
                <path d="M21 14v1" />
              </svg>
              <h1 className="text-lg font-semibold">PDVerse</h1>
            </div>
          </div>
          <div className="flex-1 overflow-auto py-2">
            <nav className="grid items-start px-2 text-sm font-medium">
              <div className="px-2 py-2 text-xs font-semibold tracking-wide text-muted-foreground">
                NAVIGATION
              </div>
              <div className="space-y-1">
                {navigation.map((item) => (
                  <Link
                    key={item.name}
                    href={item.href}
                    className={`flex items-center gap-3 rounded-lg px-3 py-2 text-muted-foreground transition-all hover:text-foreground ${
                      pathname === item.href ? "bg-muted text-foreground" : ""
                    }`}
                  >
                    {item.icon}
                    {item.name}
                  </Link>
                ))}
              </div>
              <div className="space-y-1 mt-4">
                {chatNavigation.map((item) => (
                  <div key={item.name}>
                    <Link
                      href={item.href}
                      className={`flex items-center gap-3 rounded-lg px-3 py-2 text-muted-foreground transition-all hover:text-foreground ${
                        pathname === item.href ? "bg-muted text-foreground" : ""
                      }`}
                    >
                      {item.icon}
                      {item.name}
                    </Link>
                    {item.subItems && (
                      <div className="ml-6 mt-1 space-y-1">
                        {item.subItems.map((subItem) => (
                          <Link
                            key={subItem.name}
                            href={subItem.href}
                            className={`block rounded-lg px-3 py-2 text-muted-foreground transition-all hover:text-foreground ${
                              pathname === subItem.href
                                ? "bg-muted text-foreground"
                                : ""
                            }`}
                          >
                            {subItem.name}
                          </Link>
                        ))}
                      </div>
                    )}
                  </div>
                ))}
              </div>
              <div className="mt-4 space-y-1">
                {settingsNavigation.map((item) => (
                  <Link
                    key={item.name}
                    href={item.href}
                    className={`flex items-center gap-3 rounded-lg px-3 py-2 text-muted-foreground transition-all hover:text-foreground ${
                      pathname === item.href ? "bg-muted text-foreground" : ""
                    }`}
                  >
                    {item.icon}
                    {item.name}
                  </Link>
                ))}
              </div>
            </nav>
          </div>
          <div className="border-t p-4">
            <div className="flex items-center gap-3">
              <div className="h-8 w-8 rounded-full bg-muted"></div>
              <div>
                <p className="text-sm font-medium">User Name</p>
                <p className="text-xs text-muted-foreground">user@example.com</p>
              </div>
            </div>
          </div>
        </aside>
        {/* Main content */}
        <div className="flex flex-1 flex-col overflow-hidden">
          <header className={`flex h-14 items-center gap-4 ${isChatPage ? '' : 'border-b'} bg-background px-4 lg:px-6`}>
            <Button
              variant="outline"
              size="icon"
              className="lg:hidden"
              onClick={toggleSidebar}
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="h-6 w-6"
              >
                <line x1="4" x2="20" y1="12" y2="12" />
                <line x1="4" x2="20" y1="6" y2="6" />
                <line x1="4" x2="20" y1="18" y2="18" />
              </svg>
              <span className="sr-only">Toggle Menu</span>
            </Button>
            <div className="w-full flex-1">
              {/* Only show search on non-chat pages */}
              {!pathname.includes('/dashboard/chat') && (
                <form>
                  <div className="relative">
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="24"
                      height="24"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground"
                    >
                      <circle cx="11" cy="11" r="8" />
                      <path d="m21 21-4.3-4.3" />
                    </svg>
                    <input
                      type="search"
                      placeholder="Search files..."
                      className="w-full rounded-md border border-input bg-background pl-8 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring"
                    />
                  </div>
                </form>
              )}
            </div>
          </header>
          <main className={`flex-1 overflow-auto ${isChatPage ? 'p-0' : 'p-4 lg:p-6'}`}>{children}</main>
        </div>
      </div>
    </div>
  );
}

================
File: app/dashboard/layout.tsx.new
================
"use client";

import { useState } from "react";
import Link from "next/link";
import { usePathname } from "next/navigation";
import { cn } from "@/lib/utils";
import { Button } from "@/components/ui/button";

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const [isSidebarOpen, setIsSidebarOpen] = useState(true);
  const pathname = usePathname();

  const toggleSidebar = () => {
    setIsSidebarOpen(!isSidebarOpen);
  };

  const navItems = [
    {
      title: "Dashboard",
      href: "/dashboard",
      icon: (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className="h-4 w-4"
        >
          <rect width="7" height="9" x="3" y="3" rx="1" />
          <rect width="7" height="5" x="14" y="3" rx="1" />
          <rect width="7" height="9" x="14" y="12" rx="1" />
          <rect width="7" height="5" x="3" y="16" rx="1" />
        </svg>
      ),
    },
    {
      title: "Files",
      href: "/dashboard/files",
      icon: (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className="h-4 w-4"
        >
          <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" />
          <polyline points="14 2 14 8 20 8" />
        </svg>
      ),
    },
    {
      title: "Chat",
      href: "/dashboard/chat",
      icon: (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className="h-4 w-4"
        >
          <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" />
        </svg>
      ),
      children: [
        {
          title: "New Chat",
          href: "/dashboard/chat",
        },
        {
          title: "Chat History",
          href: "/dashboard/chat/history",
        },
      ],
    },
    {
      title: "Settings",
      href: "/dashboard/settings",
      icon: (
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
          className="h-4 w-4"
        >
          <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z" />
          <circle cx="12" cy="12" r="3" />
        </svg>
      ),
    },
  ];

  return (
    <div className="flex h-screen overflow-hidden">
      {/* Sidebar */}
      <aside
        className={cn(
          "fixed inset-y-0 left-0 z-50 flex w-64 flex-col border-r bg-background transition-transform lg:static lg:translate-x-0",
          isSidebarOpen ? "translate-x-0" : "-translate-x-full"
        )}
      >
        <div className="flex h-14 items-center border-b px-4">
          <Link href="/dashboard" className="flex items-center gap-2 font-semibold">
            <span className="text-primary text-xl">PDVerse</span>
          </Link>
        </div>
        <nav className="flex-1 overflow-auto py-4">
          <div className="px-3">
            <h2 className="mb-2 px-4 text-xs font-semibold uppercase tracking-wide">
              Navigation
            </h2>
            <div className="space-y-1">
              {navItems.map((item) => (
                <div key={item.href}>
                  <Link
                    href={item.href}
                    className={cn(
                      "flex items-center gap-3 rounded-md px-3 py-2 text-sm font-medium hover:bg-accent hover:text-accent-foreground",
                      pathname === item.href
                        ? "bg-accent text-accent-foreground"
                        : "transparent"
                    )}
                  >
                    {item.icon}
                    {item.title}
                  </Link>
                  {item.children && (
                    <div className="ml-8 mt-2 space-y-1">
                      {item.children.map((child) => (
                        <Link
                          key={child.href}
                          href={child.href}
                          className={cn(
                            "flex items-center gap-3 rounded-md px-3 py-2 text-sm font-medium hover:bg-accent hover:text-accent-foreground",
                            pathname === child.href
                              ? "bg-accent text-accent-foreground"
                              : "transparent"
                          )}
                        >
                          {child.title}
                        </Link>
                      ))}
                    </div>
                  )}
                </div>
              ))}
            </div>
          </div>
        </nav>
        <div className="border-t p-4">
          <div className="flex items-center gap-3">
            <div className="h-8 w-8 rounded-full bg-muted"></div>
            <div>
              <p className="text-sm font-medium">User Name</p>
              <p className="text-xs text-muted-foreground">user@example.com</p>
            </div>
          </div>
        </div>
      </aside>
      {/* Main content */}
      <div className="flex flex-1 flex-col overflow-hidden">
        <header className="flex h-14 items-center gap-4 border-b bg-background px-4 lg:px-6">
          <Button
            variant="outline"
            size="icon"
            className="lg:hidden"
            onClick={toggleSidebar}
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
              className="h-6 w-6"
            >
              <line x1="4" x2="20" y1="12" y2="12" />
              <line x1="4" x2="20" y1="6" y2="6" />
              <line x1="4" x2="20" y1="18" y2="18" />
            </svg>
            <span className="sr-only">Toggle Menu</span>
          </Button>
          <div className="w-full flex-1">
            {/* Hide search bar on chat page */}
            {!pathname.includes('/dashboard/chat') && (
              <form>
                <div className="relative">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground"
                  >
                    <circle cx="11" cy="11" r="8" />
                    <path d="m21 21-4.3-4.3" />
                  </svg>
                  <input
                    type="search"
                    placeholder="Search files..."
                    className="w-full rounded-md border border-input bg-background pl-8 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring"
                  />
                </div>
              </form>
            )}
          </div>
        </header>
        <main className="flex-1 overflow-auto p-4 lg:p-6">{children}</main>
      </div>
    </div>
  );
}

================
File: app/dashboard/page.tsx
================
"use client";

import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import Link from "next/link";
import { Button } from "@/components/ui/button";

export default function DashboardPage() {
  return (
    <div className="flex flex-col gap-6">
      <div className="flex items-center justify-between">
        <h1 className="text-3xl font-bold tracking-tight">Dashboard</h1>
        <Button asChild>
          <Link href="/dashboard/files/upload">Upload PDF</Link>
        </Button>
      </div>
      <div className="grid gap-6 sm:grid-cols-2 lg:grid-cols-4">
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium">Total Files</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">25</div>
            <p className="text-xs text-muted-foreground">
              +2 from last week
            </p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium">Storage Used</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">128 MB</div>
            <p className="text-xs text-muted-foreground">
              of 1 GB (12.8%)
            </p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium">Recent Files</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">5</div>
            <p className="text-xs text-muted-foreground">
              in the last 7 days
            </p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm font-medium">AI Chats</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">12</div>
            <p className="text-xs text-muted-foreground">
              about your documents
            </p>
          </CardContent>
        </Card>
      </div>
      <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-7">
        <Card className="col-span-4">
          <CardHeader>
            <CardTitle>Recent Files</CardTitle>
            <CardDescription>
              Your recently uploaded or accessed PDF files
            </CardDescription>
          </CardHeader>
          <CardContent>
            <div className="space-y-4">
              {[1, 2, 3, 4, 5].map((i) => (
                <div key={i} className="flex items-center gap-4">
                  <div className="flex h-10 w-10 items-center justify-center rounded-md bg-primary/10">
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="24"
                      height="24"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      className="h-5 w-5 text-primary"
                    >
                      <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" />
                      <polyline points="14 2 14 8 20 8" />
                    </svg>
                  </div>
                  <div className="flex-1">
                    <p className="text-sm font-medium">Document-{i}.pdf</p>
                    <p className="text-xs text-muted-foreground">
                      {(i * 0.5).toFixed(1)} MB â¢ Updated {i} day{i !== 1 ? "s" : ""} ago
                    </p>
                  </div>
                  <Button variant="ghost" size="icon" asChild>
                    <Link href={`/dashboard/files/${i}`}>
                      <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="24"
                        height="24"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        className="h-4 w-4"
                      >
                        <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" />
                        <polyline points="15 3 21 3 21 9" />
                        <line x1="10" x2="21" y1="14" y2="3" />
                      </svg>
                    </Link>
                  </Button>
                </div>
              ))}
            </div>
            <div className="mt-4 flex justify-center">
              <Button variant="outline" asChild className="w-full">
                <Link href="/dashboard/files">View All Files</Link>
              </Button>
            </div>
          </CardContent>
        </Card>
        <Card className="col-span-3">
          <CardHeader>
            <CardTitle>Recent AI Chats</CardTitle>
            <CardDescription>
              Your recent conversations with the AI assistant
            </CardDescription>
          </CardHeader>
          <CardContent>
            <div className="space-y-4">
              {[1, 2, 3].map((i) => (
                <div key={i} className="flex items-center gap-4">
                  <div className="flex h-10 w-10 items-center justify-center rounded-md bg-primary/10">
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="24"
                      height="24"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      className="h-5 w-5 text-primary"
                    >
                      <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" />
                    </svg>
                  </div>
                  <div className="flex-1">
                    <p className="text-sm font-medium">Chat Session #{i}</p>
                    <p className="text-xs text-muted-foreground">
                      {i * 3} messages â¢ {i} day{i !== 1 ? "s" : ""} ago
                    </p>
                  </div>
                  <Button variant="ghost" size="icon" asChild>
                    <Link href={`/dashboard/chat/${i}`}>
                      <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="24"
                        height="24"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        className="h-4 w-4"
                      >
                        <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" />
                        <polyline points="15 3 21 3 21 9" />
                        <line x1="10" x2="21" y1="14" y2="3" />
                      </svg>
                    </Link>
                  </Button>
                </div>
              ))}
            </div>
            <div className="mt-4 flex justify-center">
              <Button variant="outline" asChild className="w-full">
                <Link href="/dashboard/chat/history">View All Chats</Link>
              </Button>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}

================
File: app/dashboard/settings/page.tsx
================
"use client";

import { useEffect, useState } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Switch } from "@/components/ui/switch";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { toast } from "sonner";

export default function SettingsPage() {
  const [apiKey, setApiKey] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [aiModel, setAiModel] = useState("gpt-4o");
  const [temperature, setTemperature] = useState(0.7);
  const [maxTokens, setMaxTokens] = useState(4096);
  const [enableHistory, setEnableHistory] = useState(true);
  const [enableLocalStorage, setEnableLocalStorage] = useState(true);
  const [storageUsage, setStorageUsage] = useState({ used: 0, total: 1000 });

  // Load saved settings on component mount
  useEffect(() => {
    const loadSettings = async () => {
      try {
        // Load API key from localStorage
        const savedApiKey = localStorage.getItem("openai_api_key");
        if (savedApiKey) {
          setApiKey(savedApiKey);
        }

        // Load AI settings from localStorage
        const savedAiModel = localStorage.getItem("ai_model") || "gpt-4o";
        const savedTemperature = parseFloat(localStorage.getItem("temperature") || "0.7");
        const savedMaxTokens = parseInt(localStorage.getItem("max_tokens") || "4096");
        const savedEnableHistory = localStorage.getItem("enable_history") !== "false";
        const savedEnableLocalStorage = localStorage.getItem("enable_local_storage") !== "false";

        setAiModel(savedAiModel);
        setTemperature(savedTemperature);
        setMaxTokens(savedMaxTokens);
        setEnableHistory(savedEnableHistory);
        setEnableLocalStorage(savedEnableLocalStorage);

        // Get storage usage
        await fetchStorageUsage();
      } catch (error) {
        console.error("Error loading settings:", error);
      }
    };

    loadSettings();
  }, []);

  // Fetch storage usage
  const fetchStorageUsage = async () => {
    try {
      const response = await fetch("/api/storage/usage");
      if (response.ok) {
        const data = await response.json();
        setStorageUsage({
          used: data.used || 0,
          total: data.total || 1000
        });
      }
    } catch (error) {
      console.error("Error fetching storage usage:", error);
    }
  };

  // Save API key
  const handleSaveApiKey = async () => {
    setIsLoading(true);
    try {
      // Save to localStorage
      localStorage.setItem("openai_api_key", apiKey);
      
      // Optional: Validate API key with a test request
      const isValid = await validateApiKey(apiKey);
      
      if (isValid) {
        toast.success("API key saved successfully");
      } else {
        toast.error("Invalid API key");
      }
    } catch (error) {
      console.error("Error saving API key:", error);
      toast.error("Failed to save API key");
    } finally {
      setIsLoading(false);
    }
  };

  // Validate API key with a test request
  const validateApiKey = async (key: string) => {
    try {
      // This is a simple validation - in production you might want to make a test request
      return key.startsWith("sk-") && key.length > 20;
    } catch (error) {
      return false;
    }
  };

  // Save AI settings
  const handleSaveAISettings = () => {
    setIsLoading(true);
    try {
      // Save settings to localStorage
      localStorage.setItem("ai_model", aiModel);
      localStorage.setItem("temperature", temperature.toString());
      localStorage.setItem("max_tokens", maxTokens.toString());
      localStorage.setItem("enable_history", enableHistory.toString());
      
      toast.success("AI settings saved successfully");
    } catch (error) {
      console.error("Error saving AI settings:", error);
      toast.error("Failed to save AI settings");
    } finally {
      setIsLoading(false);
    }
  };

  // Save storage settings
  const handleSaveStorageSettings = () => {
    setIsLoading(true);
    try {
      localStorage.setItem("enable_local_storage", enableLocalStorage.toString());
      toast.success("Storage settings saved successfully");
    } catch (error) {
      console.error("Error saving storage settings:", error);
      toast.error("Failed to save storage settings");
    } finally {
      setIsLoading(false);
    }
  };

  // Clear all data
  const handleClearAllData = async () => {
    if (confirm("Are you sure you want to clear all data? This action cannot be undone.")) {
      setIsLoading(true);
      try {
        // Clear localStorage except for settings
        const settingsToKeep = {
          openai_api_key: localStorage.getItem("openai_api_key"),
          ai_model: localStorage.getItem("ai_model"),
          temperature: localStorage.getItem("temperature"),
          max_tokens: localStorage.getItem("max_tokens"),
          enable_history: localStorage.getItem("enable_history"),
          enable_local_storage: localStorage.getItem("enable_local_storage")
        };
        
        localStorage.clear();
        
        // Restore settings
        Object.entries(settingsToKeep).forEach(([key, value]) => {
          if (value) localStorage.setItem(key, value);
        });
        
        // Clear IndexedDB or other storage as needed
        
        toast.success("All data cleared successfully");
        await fetchStorageUsage();
      } catch (error) {
        console.error("Error clearing data:", error);
        toast.error("Failed to clear data");
      } finally {
        setIsLoading(false);
      }
    }
  };

  // Format bytes to human-readable format
  const formatBytes = (bytes: number) => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  };

  return (
    <div className="container mx-auto py-6">
      <h1 className="text-3xl font-bold tracking-tight mb-6">Settings</h1>
      
      <Tabs defaultValue="ai" className="w-full">
        <TabsList className="grid w-full md:w-[400px] grid-cols-2">
          <TabsTrigger value="ai">AI Settings</TabsTrigger>
          <TabsTrigger value="storage">Storage</TabsTrigger>
        </TabsList>
        
        <TabsContent value="ai" className="mt-6 space-y-6">
          <Card>
            <CardHeader>
              <CardTitle>API Configuration</CardTitle>
              <CardDescription>
                Configure your OpenAI API key for AI chat functionality
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="api-key">OpenAI API Key</Label>
                <Input
                  id="api-key"
                  type="password"
                  placeholder="sk-..."
                  value={apiKey}
                  onChange={(e) => setApiKey(e.target.value)}
                />
                <p className="text-sm text-muted-foreground">
                  Your API key is stored locally and never sent to our servers
                </p>
              </div>
            </CardContent>
            <CardFooter>
              <Button onClick={handleSaveApiKey} disabled={isLoading || !apiKey}>
                {isLoading ? "Saving..." : "Save API Key"}
              </Button>
            </CardFooter>
          </Card>

          <Card>
            <CardHeader>
              <CardTitle>AI Model Settings</CardTitle>
              <CardDescription>
                Configure the AI model and parameters for chat
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-2">
                <Label htmlFor="ai-model">AI Model</Label>
                <Select value={aiModel} onValueChange={setAiModel}>
                  <SelectTrigger id="ai-model" className="w-full">
                    <SelectValue placeholder="Select a model" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="gpt-4o">GPT-4o (Recommended)</SelectItem>
                    <SelectItem value="gpt-4-turbo">GPT-4 Turbo</SelectItem>
                    <SelectItem value="gpt-4">GPT-4</SelectItem>
                    <SelectItem value="gpt-3.5-turbo">GPT-3.5 Turbo</SelectItem>
                  </SelectContent>
                </Select>
                <p className="text-sm text-muted-foreground">
                  GPT-4o offers the best performance for PDF analysis
                </p>
              </div>

              <div className="space-y-2">
                <Label htmlFor="temperature">
                  Temperature: {temperature}
                </Label>
                <Input
                  id="temperature"
                  type="range"
                  min="0"
                  max="1"
                  step="0.1"
                  value={temperature}
                  onChange={(e) => setTemperature(parseFloat(e.target.value))}
                  className="w-full"
                />
                <p className="text-sm text-muted-foreground">
                  Lower values make responses more deterministic, higher values more creative
                </p>
              </div>

              <div className="space-y-2">
                <Label htmlFor="max-tokens">
                  Max Tokens: {maxTokens}
                </Label>
                <Input
                  id="max-tokens"
                  type="range"
                  min="1000"
                  max="8000"
                  step="100"
                  value={maxTokens}
                  onChange={(e) => setMaxTokens(parseInt(e.target.value))}
                  className="w-full"
                />
                <p className="text-sm text-muted-foreground">
                  Maximum length of AI responses (8000 max for GPT-4o)
                </p>
              </div>

              <div className="flex items-center space-x-2">
                <Switch
                  id="enable-history"
                  checked={enableHistory}
                  onCheckedChange={setEnableHistory}
                />
                <Label htmlFor="enable-history">Save chat history</Label>
              </div>
            </CardContent>
            <CardFooter>
              <Button onClick={handleSaveAISettings} disabled={isLoading}>
                {isLoading ? "Saving..." : "Save AI Settings"}
              </Button>
            </CardFooter>
          </Card>
        </TabsContent>
        
        <TabsContent value="storage" className="mt-6 space-y-6">
          <Card>
            <CardHeader>
              <CardTitle>Storage Settings</CardTitle>
              <CardDescription>
                Configure how PDVerse stores your files and data
              </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="flex items-center space-x-2">
                <Switch
                  id="local-storage"
                  checked={enableLocalStorage}
                  onCheckedChange={setEnableLocalStorage}
                />
                <Label htmlFor="local-storage">Use local storage</Label>
              </div>
              <p className="text-sm text-muted-foreground">
                Store all files and data locally on your device
              </p>

              <div className="space-y-2 mt-4">
                <Label>Storage Usage</Label>
                <div className="w-full bg-muted rounded-full h-2.5">
                  <div 
                    className="bg-primary h-2.5 rounded-full" 
                    style={{ width: `${Math.min(100, (storageUsage.used / storageUsage.total) * 100)}%` }}
                  ></div>
                </div>
                <div className="flex justify-between text-xs text-muted-foreground">
                  <span>{formatBytes(storageUsage.used)} used</span>
                  <span>{formatBytes(storageUsage.total)} total</span>
                </div>
              </div>
            </CardContent>
            <CardFooter>
              <Button 
                variant="outline" 
                className="mr-2" 
                onClick={handleClearAllData}
                disabled={isLoading}
              >
                Clear All Data
              </Button>
              <Button 
                onClick={handleSaveStorageSettings} 
                disabled={isLoading}
              >
                Save Storage Settings
              </Button>
            </CardFooter>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
}

================
File: app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;
 
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;
    --primary: 240 5.9% 10%;
    --primary-foreground: 0 0% 98%;
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;
    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 240 5.9% 10%;
    --radius: 0.5rem;
  }
 
  .dark {
    --background: 240 10% 3.9%;
    --foreground: 0 0% 98%;
    --card: 240 10% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 240 10% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 240 5.9% 10%;
    --secondary: 240 3.7% 15.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 240 3.7% 15.9%;
    --muted-foreground: 240 5% 64.9%;
    --accent: 240 3.7% 15.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 3.7% 15.9%;
    --input: 240 3.7% 15.9%;
    --ring: 240 4.9% 83.9%;
  }
}
 
@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

.pdf-container {
  height: 100%;
  overflow: auto;
}

.react-pdf__Document {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.react-pdf__Page {
  margin: 1rem;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
}

.react-pdf__Page__canvas {
  max-width: 100%;
  height: auto !important;
}

/* PDF Viewer Styles */
.fullscreen-pdf {
  position: fixed !important;
  top: 0;
  left: 0;
  width: 100vw !important;
  height: 100vh !important;
  z-index: 9999;
  background-color: hsl(var(--background));
  padding: 1rem;
  overflow: auto;
}

/* PDF Outline Styles */
.react-pdf__Outline {
  font-size: 0.875rem;
}

.react-pdf__Outline__item {
  margin-bottom: 0.25rem;
}

.react-pdf__Outline__item__link {
  color: hsl(var(--foreground));
  text-decoration: none;
  display: block;
  padding: 0.25rem 0;
  transition: background-color 0.2s;
  border-radius: 0.25rem;
}

.react-pdf__Outline__item__link:hover {
  background-color: hsl(var(--accent));
}

/* PDF Text Layer Styles */
.react-pdf__Page__textContent {
  user-select: text;
}

.react-pdf__Page__textContent span {
  opacity: 0.4;
}

.react-pdf__Page__textContent span::selection {
  background-color: hsl(var(--primary) / 0.3);
}

/* PDF Annotation Layer Styles */
.react-pdf__Page__annotations {
  pointer-events: none;
}

================
File: app/layout.tsx
================
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';
import { ThemeProvider } from '@/components/theme-provider';
import { Toaster } from 'sonner';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'PDVerse - PDF Management with AI Chat',
  description: 'Manage your PDF documents with the help of AI',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={inter.className}>
        <ThemeProvider
          attribute="class"
          defaultTheme="system"
          enableSystem
          disableTransitionOnChange
        >
          {children}
          <Toaster position="top-center" />
        </ThemeProvider>
      </body>
    </html>
  );
}

================
File: app/lib/logger.ts
================
import { Logger } from 'next-axiom';

export const logger = new Logger();

================
File: app/lib/python-backend.ts
================
// lib/python-backend.ts
export async function searchDocumentsInPythonBackend(
  query: string,
  options?: {
    document_id?: string;
    limit?: number;
    offset?: number;
    search_type?: 'fulltext' | 'vector' | 'hybrid';
    vector_weight?: number;
    text_weight?: number;
    filters?: Record<string, any>;
  }
): Promise<{
  results: any[];
  total: number;
  query: string;
}> {
  try {
    const response = await fetch('/api/search', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        query,
        document_id: options?.document_id,
        limit: options?.limit || 10,
        offset: options?.offset || 0,
        search_type: options?.search_type || 'hybrid',
        vector_weight: options?.vector_weight || 0.65,
        text_weight: options?.text_weight || 0.35,
        filters: options?.filters || {},
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.detail || `Search failed with status ${response.status}`);
    }

    const data = await response.json();
    return {
      results: data.results || [],
      total: data.total || 0,
      query: data.query || query,
    };
  } catch (error) {
    console.error('Search operation failed:', error);
    throw error;
  }
}

export async function getDocumentsFromPythonBackend(id?: string) {
  try {
    const baseUrl = '/api/python-backend?endpoint=documents';
    const url = id ? `${baseUrl}/${id}` : baseUrl;
    const response = await fetch(url);
    if (!response.ok) throw new Error(`Failed to fetch documents: ${response.statusText}`);
    return await response.json();
  } catch (error) {
    console.error('Error fetching documents:', error);
    throw error;
  }
}

export async function queryDocumentWithLLM(query: string, documentId: string, chatMode: string) {
  try {
    const pythonBackendUrl = process.env.PYTHON_BACKEND_URL || 'http://localhost:8000';
    const apiKey = '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'; // From your working curl
    
    const response = await fetch(`${pythonBackendUrl}/query`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        query,
        document_id: documentId,
        chat_mode: chatMode,
        api_key: apiKey,
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('queryDocumentWithLLM error:', errorText);
      throw new Error(`Failed to query document: ${errorText}`);
    }

    const result = await response.json();
    console.log('queryDocumentWithLLM response:', result);
    return result;
  } catch (error) {
    console.error('queryDocumentWithLLM failed:', error);
    throw error;
  }
}

export async function getDocumentFromPythonBackend(documentId: string) {
  try {
    const pythonBackendUrl = process.env.PYTHON_BACKEND_URL || 'http://localhost:8000';
    
    const response = await fetch(`${pythonBackendUrl}/document/${documentId}`, {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Failed to fetch document: ${errorText}`);
    }

    return await response.json();
  } catch (error) {
    console.error('getDocumentFromPythonBackend error:', error);
    throw error;
  }
}

================
File: app/lib/utils.ts
================
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function formatBytes(bytes: number, decimals = 2) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}

export function truncateFilename(filename: string, maxLength = 30) {
  if (filename.length <= maxLength) return filename;
  
  const extension = filename.split('.').pop();
  const baseName = filename.slice(0, filename.lastIndexOf('.'));
  const maxBaseLength = maxLength - (extension?.length || 0) - 1; // -1 for the dot
  
  if (maxBaseLength <= 0) return filename;
  
  return baseName.length > maxBaseLength 
    ? `${baseName.slice(0, maxBaseLength/2)}â¦${baseName.slice(-maxBaseLength/2 + 1)}.${extension}`
    : `${baseName}.${extension}`;
}

export function isValidPdf(file: File) {
  return file.type === 'application/pdf' && 
         file.name.toLowerCase().endsWith('.pdf');
}

================
File: app/page.tsx
================
"use client";

import { Button } from "@/components/ui/button";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { searchDocumentsInPythonBackend } from '@/lib/python-backend';


export default function Home() {
  const router = useRouter();

  return (
    <div className="flex flex-col min-h-screen">
      <header className="border-b">
        <div className="container flex h-16 items-center px-4 sm:px-6 lg:px-8">
          <div className="flex items-center gap-2 font-bold text-2xl">
            <span className="text-primary">PDVerse</span>
          </div>
          <nav className="ml-auto flex gap-4 sm:gap-6">
            <Button asChild variant="ghost">
              <Link href="/login">Login</Link>
            </Button>
            <Button asChild>
              <Link href="/register">Register</Link>
            </Button>
          </nav>
        </div>
      </header>
      <main className="flex-1">
        <section className="w-full py-12 md:py-24 lg:py-32 xl:py-48">
          <div className="container px-4 md:px-6">
            <div className="grid gap-6 lg:grid-cols-[1fr_400px] lg:gap-12 xl:grid-cols-[1fr_600px]">
              <div className="flex flex-col justify-center space-y-4">
                <div className="space-y-2">
                  <h1 className="text-3xl font-bold tracking-tighter sm:text-5xl xl:text-6xl/none">
                    Manage Your PDFs with AI Assistance
                  </h1>
                  <p className="max-w-[600px] text-muted-foreground md:text-xl">
                    Upload, organize, and analyze your PDF documents with the help of our AI assistant.
                    All your files stay local with optional cloud AI integration.
                  </p>
                </div>
                <div className="flex flex-col gap-2 min-[400px]:flex-row">
                  <Button onClick={() => router.push("/dashboard")} size="lg">
                    Get Started
                  </Button>
                  <Button variant="outline" size="lg" asChild>
                    <Link href="/about">Learn More</Link>
                  </Button>
                </div>
              </div>
              <div className="flex items-center justify-center">
                <div className="relative h-[350px] w-full overflow-hidden rounded-xl bg-muted md:h-[450px] lg:h-[500px]">
                  <div className="absolute inset-0 bg-gradient-to-br from-primary/20 to-secondary/20 z-10"></div>
                  <div className="absolute inset-0 flex items-center justify-center">
                    <div className="grid grid-cols-2 gap-4 p-4">
                      <div className="h-40 w-32 rounded-lg bg-background shadow-lg"></div>
                      <div className="h-40 w-32 rounded-lg bg-background shadow-lg"></div>
                      <div className="h-40 w-32 rounded-lg bg-background shadow-lg"></div>
                      <div className="h-40 w-32 rounded-lg bg-background shadow-lg"></div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </section>
        <section className="w-full py-12 md:py-24 lg:py-32 bg-muted">
          <div className="container px-4 md:px-6">
            <div className="flex flex-col items-center justify-center space-y-4 text-center">
              <div className="space-y-2">
                <h2 className="text-3xl font-bold tracking-tighter sm:text-5xl">
                  Key Features
                </h2>
                <p className="max-w-[900px] text-muted-foreground md:text-xl/relaxed lg:text-base/relaxed xl:text-xl/relaxed">
                  Everything you need to manage your PDF documents effectively
                </p>
              </div>
            </div>
            <div className="mx-auto grid max-w-5xl grid-cols-1 gap-6 py-12 md:grid-cols-2 lg:grid-cols-3">
              <div className="flex flex-col items-center space-y-2 rounded-lg border p-6 shadow-sm">
                <div className="flex h-12 w-12 items-center justify-center rounded-full bg-primary text-primary-foreground">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    className="h-6 w-6"
                  >
                    <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z" />
                    <polyline points="14 2 14 8 20 8" />
                  </svg>
                </div>
                <h3 className="text-xl font-bold">PDF Management</h3>
                <p className="text-sm text-muted-foreground text-center">
                  Upload, organize, view, and delete PDF documents with ease
                </p>
              </div>
              <div className="flex flex-col items-center space-y-2 rounded-lg border p-6 shadow-sm">
                <div className="flex h-12 w-12 items-center justify-center rounded-full bg-primary text-primary-foreground">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    className="h-6 w-6"
                  >
                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z" />
                  </svg>
                </div>
                <h3 className="text-xl font-bold">AI Chat Assistant</h3>
                <p className="text-sm text-muted-foreground text-center">
                  Get help with document analysis and content extraction
                </p>
              </div>
              <div className="flex flex-col items-center space-y-2 rounded-lg border p-6 shadow-sm">
                <div className="flex h-12 w-12 items-center justify-center rounded-full bg-primary text-primary-foreground">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    className="h-6 w-6"
                  >
                    <path d="M20 7h-3a2 2 0 0 1-2-2V2" />
                    <path d="M9 18a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h7l4 4v10a2 2 0 0 1-2 2Z" />
                    <path d="M3 15h6" />
                    <path d="M3 18h6" />
                  </svg>
                </div>
                <h3 className="text-xl font-bold">Local Operation</h3>
                <p className="text-sm text-muted-foreground text-center">
                  Your files stay on your device with optional AI API integration
                </p>
              </div>
            </div>
          </div>
        </section>
      </main>
      <footer className="border-t py-6 md:py-0">
        <div className="container flex flex-col items-center justify-between gap-4 md:h-16 md:flex-row">
          <p className="text-sm text-muted-foreground">
            &copy; {new Date().getFullYear()} PDVerse. All rights reserved.
          </p>
          <div className="flex gap-4">
            <Link
              href="/terms"
              className="text-sm text-muted-foreground underline-offset-4 hover:underline"
            >
              Terms
            </Link>
            <Link
              href="/privacy"
              className="text-sm text-muted-foreground underline-offset-4 hover:underline"
            >
              Privacy
            </Link>
          </div>
        </div>
      </footer>
    </div>
  );
}

================
File: components/animated-sidebar-button.tsx
================
'use client';

import { useTheme } from 'next-themes';
import { useEffect, useState } from 'react';

interface AnimatedSidebarButtonProps {
  onClick: () => void;
  isOpen: boolean;
}

export default function AnimatedSidebarButton({ onClick, isOpen }: AnimatedSidebarButtonProps) {
  const { resolvedTheme } = useTheme();
  const [mounted, setMounted] = useState(false);

  // Wait for mounting to avoid hydration mismatch
  useEffect(() => {
    setMounted(true);
  }, []);

  const isDarkMode = mounted && resolvedTheme === 'dark';
  const iconColor = isDarkMode ? '#f0eeef' : '#000000';
  const borderColor = isDarkMode ? '#f0eeef' : '#000000';
  const bgColor = isDarkMode ? '#1e1e2e' : '#ffffff';

  return (
    <div className="styled-wrapper">
      <button className="button" onClick={onClick} aria-label={isOpen ? "Hide Sidebar" : "Show Sidebar"}>
        <div className={`button-box ${isOpen ? '' : 'rotated'}`}>
          <span className="button-elem">
            <svg
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
              className="arrow-icon"
            >
              <path
                fill={iconColor}
                d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"
              ></path>
            </svg>
          </span>
          <span className="button-elem">
            <svg
              viewBox="0 0 24 24"
              xmlns="http://www.w3.org/2000/svg"
              className="arrow-icon"
            >
              <path
                fill={iconColor}
                d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"
              ></path>
            </svg>
          </span>
        </div>
      </button>

      <style jsx>{`
        .styled-wrapper {
          position: relative;
          width: 32px;
          height: 32px;
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
          border-radius: 50%;
          background-color: ${bgColor};
          z-index: 30;
        }
        
        .styled-wrapper .button {
          display: flex;
          align-items: center;
          justify-content: center;
          position: relative;
          width: 32px;
          height: 32px;
          margin: 0;
          overflow: hidden;
          outline: none;
          background-color: transparent;
          cursor: pointer;
          border: 0;
          border-radius: 50%;
        }

        .styled-wrapper .button:before {
          content: "";
          position: absolute;
          border-radius: 50%;
          inset: 3px;
          border: 1.5px solid ${borderColor};
          transition:
            opacity 0.4s cubic-bezier(0.77, 0, 0.175, 1) 80ms,
            transform 0.5s cubic-bezier(0.455, 0.03, 0.515, 0.955) 80ms;
        }

        .styled-wrapper .button:after {
          content: "";
          position: absolute;
          border-radius: 50%;
          inset: 3px;
          border: 1.5px solid ${isDarkMode ? '#599a53' : '#599a53'};
          transform: scale(1.3);
          transition:
            opacity 0.4s cubic-bezier(0.165, 0.84, 0.44, 1),
            transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
          opacity: 0;
        }

        .styled-wrapper .button:hover:before,
        .styled-wrapper .button:focus:before {
          opacity: 0;
          transform: scale(0.7);
          transition:
            opacity 0.4s cubic-bezier(0.165, 0.84, 0.44, 1),
            transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .styled-wrapper .button:hover:after,
        .styled-wrapper .button:focus:after {
          opacity: 1;
          transform: scale(1);
          transition:
            opacity 0.4s cubic-bezier(0.77, 0, 0.175, 1) 80ms,
            transform 0.5s cubic-bezier(0.455, 0.03, 0.515, 0.955) 80ms;
        }

        .styled-wrapper .button-box {
          display: flex;
          position: absolute;
          height: 100%;
          width: 100%;
          align-items: center;
          justify-content: center;
          transition: transform 0.4s ease;
        }
        
        .styled-wrapper .button-box.rotated {
          transform: rotate(180deg);
        }

        .styled-wrapper .button-elem {
          display: flex;
          align-items: center;
          justify-content: center;
          width: 16px;
          height: 16px;
          position: absolute;
        }
        
        .styled-wrapper .button-elem:nth-child(1) {
          opacity: 1;
          transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        .styled-wrapper .button-elem:nth-child(2) {
          opacity: 0;
          transform: translateX(-20px);
          transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .styled-wrapper .button:hover .button-elem:nth-child(1) {
          opacity: 0;
          transform: translateX(20px);
        }
        
        .styled-wrapper .button:hover .button-elem:nth-child(2) {
          opacity: 1;
          transform: translateX(0);
        }
        
        .styled-wrapper .arrow-icon {
          width: 100%;
          height: 100%;
        }
      `}</style>
    </div>
  );
}

================
File: components/theme-provider.tsx
================
"use client";

import * as React from "react";
import { ThemeProvider as NextThemesProvider } from "next-themes";
import { type ThemeProviderProps } from "next-themes/dist/types";

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>;
}

================
File: components/theme-toggle.tsx
================
"use client";

import * as React from "react";
import { useTheme } from "next-themes";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { SunIcon, MoonIcon, LaptopIcon } from "lucide-react";

export function ThemeToggle() {
  const { setTheme, theme } = useTheme();

  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline" size="icon" className="h-9 w-9">
          <SunIcon className="h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" />
          <MoonIcon className="absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" />
          <span className="sr-only">Toggle theme</span>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => setTheme("light")}>
          <SunIcon className="mr-2 h-4 w-4" />
          <span>Light</span>
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("dark")}>
          <MoonIcon className="mr-2 h-4 w-4" />
          <span>Dark</span>
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => setTheme("system")}>
          <LaptopIcon className="mr-2 h-4 w-4" />
          <span>System</span>
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
}

================
File: components/ui/badge.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

================
File: components/ui/button.tsx
================
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  }
);
Button.displayName = "Button";

export { Button, buttonVariants };

================
File: components/ui/card.tsx
================
import * as React from "react";
import { cn } from "@/lib/utils";

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
));
Card.displayName = "Card";

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
));
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
));
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
));
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
));
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
));
CardFooter.displayName = "CardFooter";

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };

================
File: components/ui/dialog.tsx
================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-background/80 backdrop-blur-sm data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

================
File: components/ui/dropdown-menu.tsx
================
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}

================
File: components/ui/input.tsx
================
import * as React from "react";
import { cn } from "@/lib/utils";

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);
Input.displayName = "Input";

export { Input };

================
File: components/ui/label.tsx
================
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };

================
File: components/ui/popover.tsx
================
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }

================
File: components/ui/select.tsx
================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

================
File: components/ui/separator.tsx
================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }

================
File: components/ui/skeleton.tsx
================
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }

================
File: components/ui/switch.tsx
================
"use client";

import * as React from "react";
import * as SwitchPrimitives from "@radix-ui/react-switch";

import { cn } from "@/lib/utils";

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
));
Switch.displayName = SwitchPrimitives.Root.displayName;

export { Switch };

================
File: components/ui/tabs.tsx
================
"use client";

import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";

import { cn } from "@/lib/utils";

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };

================
File: components/ui/textarea.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }



// Initialize the database
initializeDatabase();

// Helper functions for common database operations

// User functions
export function createUser(data: { name?: string; email: string }) {
  const stmt = db.prepare(`
    INSERT INTO users (id, name, email, created_at, updated_at)
    VALUES (?, ?, ?, unixepoch(), unixepoch())
  `);
  
  const id = uuidv4();
  stmt.run(id, data.name || null, data.email);
  
  return getUserById(id);
}

export function getUserById(id: string) {
  const stmt = db.prepare('SELECT * FROM users WHERE id = ?');
  return stmt.get(id);
}

export function getUserByEmail(email: string) {
  const stmt = db.prepare('SELECT * FROM users WHERE email = ?');
  return stmt.get(email);
}

// File type
export type FileRecord = {
  id: string;
  filename: string;
  original_filename: string;
  size: number;
  path: string;
  mimetype: string;
  user_id?: string;
  created_at: number;
  updated_at: number;
};

// File functions
export function createFile(data: {
  filename: string;
  originalFilename: string;
  size: number;
  path: string;
  mimetype: string;
  userId?: string;
}): FileRecord {
  const stmt = db.prepare(`
    INSERT INTO files (id, filename, original_filename, size, path, mimetype, user_id, created_at, updated_at)
    VALUES (?, ?, ?, ?, ?, ?, ?, unixepoch(), unixepoch())
  `);
  
  const id = uuidv4();
  stmt.run(
    id,
    data.filename,
    data.originalFilename,
    data.size,
    data.path,
    data.mimetype,
    data.userId || null
  );
  
  return getFileById(id) as FileRecord;
}

export function getFileById(id: string): FileRecord | undefined {
  const stmt = db.prepare('SELECT * FROM files WHERE id = ?');
  return stmt.get(id) as FileRecord | undefined;
}

export function getAllFiles(userId?: string): FileRecord[] {
  let stmt;
  if (userId) {
    stmt = db.prepare('SELECT * FROM files WHERE user_id = ? ORDER BY created_at DESC');
    return stmt.all(userId) as FileRecord[];
  } else {
    stmt = db.prepare('SELECT * FROM files ORDER BY created_at DESC');
    return stmt.all() as FileRecord[];
  }
}

export function updateFile(id: string, data: Partial<{
  filename: string;
  originalFilename: string;
  size: number;
  path: string;
  mimetype: string;
  userId: string;
}>) {
  const updates = Object.entries(data)
    .filter(([_, value]) => value !== undefined)
    .map(([key, _]) => {
      // Convert camelCase to snake_case
      return `${key.replace(/([A-Z])/g, '_$1').toLowerCase()} = ?`;
    });
  
  if (updates.length === 0) return getFileById(id);
  
  const sql = `
    UPDATE files
    SET ${updates.join(', ')}, updated_at = unixepoch()
    WHERE id = ?
  `;
  
  const stmt = db.prepare(sql);
  const values = [...Object.values(data).filter(v => v !== undefined), id];
  stmt.run(...values);
  
  return getFileById(id);
}

export function deleteFile(id: string) {
  const stmt = db.prepare('DELETE FROM files WHERE id = ?');
  return stmt.run(id);
}

// Tag functions
export function createTag(data: { name: string; userId?: string }) {
  const stmt = db.prepare(`
    INSERT INTO tags (id, name, user_id, created_at)
    VALUES (?, ?, ?, unixepoch())
  `);
  
  const id = uuidv4();
  stmt.run(id, data.name, data.userId || null);
  
  return getTagById(id);
}

export function getTagById(id: string) {
  const stmt = db.prepare('SELECT * FROM tags WHERE id = ?');
  return stmt.get(id);
}

export function getAllTags(userId?: string) {
  let stmt;
  if (userId) {
    stmt = db.prepare('SELECT * FROM tags WHERE user_id = ? OR user_id IS NULL ORDER BY name');
    return stmt.all(userId);
  } else {
    stmt = db.prepare('SELECT * FROM tags ORDER BY name');
    return stmt.all();
  }
}

// File tag functions
export function addTagToFile(fileId: string, tagId: string) {
  const stmt = db.prepare(`
    INSERT OR IGNORE INTO file_tags (file_id, tag_id, created_at)
    VALUES (?, ?, unixepoch())
  `);
  
  return stmt.run(fileId, tagId);
}

export function removeTagFromFile(fileId: string, tagId: string) {
  const stmt = db.prepare('DELETE FROM file_tags WHERE file_id = ? AND tag_id = ?');
  return stmt.run(fileId, tagId);
}

export function getFilesByTag(tagId: string) {
  const stmt = db.prepare(`
    SELECT f.*
    FROM files f
    JOIN file_tags ft ON f.id = ft.file_id
    WHERE ft.tag_id = ?
    ORDER BY f.created_at DESC
  `);
  
  return stmt.all(tagId);
}

export function getTagsByFile(fileId: string) {
  const stmt = db.prepare(`
    SELECT t.*
    FROM tags t
    JOIN file_tags ft ON t.id = ft.tag_id
    WHERE ft.file_id = ?
    ORDER BY t.name
  `);
  
  return stmt.all(fileId);
}

// Chat functions
export function createChatSession(data: { title: string; userId?: string }) {
  const stmt = db.prepare(`
    INSERT INTO chat_sessions (id, title, user_id, created_at, updated_at)
    VALUES (?, ?, ?, unixepoch(), unixepoch())
  `);
  
  const id = uuidv4();
  stmt.run(id, data.title, data.userId || null);
  
  return getChatSessionById(id);
}

export function getChatSessionById(id: string) {
  const stmt = db.prepare('SELECT * FROM chat_sessions WHERE id = ?');
  return stmt.get(id);
}

export function getAllChatSessions(userId?: string) {
  let stmt;
  if (userId) {
    stmt = db.prepare('SELECT * FROM chat_sessions WHERE user_id = ? ORDER BY updated_at DESC');
    return stmt.all(userId);
  } else {
    stmt = db.prepare('SELECT * FROM chat_sessions ORDER BY updated_at DESC');
    return stmt.all();
  }
}

export function updateChatSession(id: string, data: { title: string }) {
  const stmt = db.prepare(`
    UPDATE chat_sessions
    SET title = ?, updated_at = unixepoch()
    WHERE id = ?
  `);
  
  stmt.run(data.title, id);
  
  return getChatSessionById(id);
}

export function deleteChatSession(id: string) {
  const stmt = db.prepare('DELETE FROM chat_sessions WHERE id = ?');
  return stmt.run(id);
}

export function addMessageToChat(data: { 
  sessionId: string; 
  role: 'user' | 'assistant' | 'system'; 
  content: string 
}) {
  const stmt = db.prepare(`
    INSERT INTO chat_messages (id, session_id, role, content, created_at)
    VALUES (?, ?, ?, ?, unixepoch())
  `);
  
  const id = uuidv4();
  stmt.run(id, data.sessionId, data.role, data.content);
  
  // Update the chat session's updated_at timestamp
  const updateStmt = db.prepare(`
    UPDATE chat_sessions
    SET updated_at = unixepoch()
    WHERE id = ?
  `);
  updateStmt.run(data.sessionId);
  
  return getMessageById(id);
}

export function getMessageById(id: string) {
  const stmt = db.prepare('SELECT * FROM chat_messages WHERE id = ?');
  return stmt.get(id);
}

export function getChatMessages(sessionId: string) {
  const stmt = db.prepare(`
    SELECT * FROM chat_messages
    WHERE session_id = ?
    ORDER BY created_at
  `);
  
  return stmt.all(sessionId);
}

export function addFileToChat(sessionId: string, fileId: string) {
  const stmt = db.prepare(`
    INSERT OR IGNORE INTO chat_session_files (session_id, file_id, created_at)
    VALUES (?, ?, unixepoch())
  `);
  
  return stmt.run(sessionId, fileId);
}

export function removeFileFromChat(sessionId: string, fileId: string) {
  const stmt = db.prepare('DELETE FROM chat_session_files WHERE session_id = ? AND file_id = ?');
  return stmt.run(sessionId, fileId);
}

export function getChatFiles(sessionId: string) {
  const stmt = db.prepare(`
    SELECT f.*
    FROM files f
    JOIN chat_session_files csf ON f.id = csf.file_id
    WHERE csf.session_id = ?
  `);
  
  return stmt.all(sessionId);
}

// PDF metadata type
export type PdfMetadata = {
  id: string;
  file_id: string;
  title?: string;
  author?: string;
  subject?: string;
  keywords?: string;
  creator?: string;
  producer?: string;
  page_count?: number;
  creation_date?: string;
  modification_date?: string;
  
  // Additional fields for AI enhancement
  summary?: string;
  document_type?: string;
  topics?: string;
  ai_enhanced?: boolean;
  needs_review?: boolean;
  
  created_at: number;
  updated_at: number;
};

// PDF metadata functions
export function savePdfMetadata(data: {
  fileId: string;
  title?: string;
  author?: string;
  subject?: string;
  keywords?: string;
  creator?: string;
  producer?: string;
  pageCount?: number;
  creationDate?: string;
  modificationDate?: string;
  summary?: string;
  documentType?: string;
  topics?: string;
  aiEnhanced?: boolean;
  needsReview?: boolean;
}) {
  // Check if metadata already exists for this file
  const existing = getPdfMetadata(data.fileId);
  
  // Convert boolean values to integers for SQLite
  const sqliteData = {
    ...data,
    aiEnhanced: data.aiEnhanced !== undefined ? (data.aiEnhanced ? 1 : 0) : undefined,
    needsReview: data.needsReview !== undefined ? (data.needsReview ? 1 : 0) : undefined
  };
  
  if (existing) {
    // Update existing metadata
    const updates = Object.entries(sqliteData)
      .filter(([key, _]) => key !== 'fileId') // Exclude fileId from updates
      .filter(([_, value]) => value !== undefined)
      .map(([key, _]) => {
        // Convert camelCase to snake_case
        return `${key.replace(/([A-Z])/g, '_$1').toLowerCase()} = ?`;
      });
    
    if (updates.length === 0) return existing;
    
    const sql = `
      UPDATE pdf_metadata
      SET ${updates.join(', ')}, updated_at = unixepoch()
      WHERE file_id = ?
    `;
    
    const stmt = db.prepare(sql);
    const values = [
      ...Object.entries(sqliteData)
        .filter(([key, _]) => key !== 'fileId')
        .filter(([_, value]) => value !== undefined)
        .map(([_, value]) => value),
      data.fileId
    ];
    
    stmt.run(...values);
  } else {
    // Insert new metadata
    const columns = ['file_id', ...Object.keys(sqliteData)
      .filter(key => key !== 'fileId' && sqliteData[key as keyof typeof sqliteData] !== undefined)
      .map(key => key.replace(/([A-Z])/g, '_$1').toLowerCase())
    ];
    
    const placeholders = columns.map(() => '?').join(', ');
    
    const sql = `
      INSERT INTO pdf_metadata (${columns.join(', ')}, created_at, updated_at)
      VALUES (${placeholders}, unixepoch(), unixepoch())
    `;
    
    const stmt = db.prepare(sql);
    const values = [
      data.fileId,
      ...Object.entries(sqliteData)
        .filter(([key, _]) => key !== 'fileId')
        .filter(([_, value]) => value !== undefined)
        .map(([_, value]) => value)
    ];
    
    stmt.run(...values);
  }
  
  return getPdfMetadata(data.fileId);
}

export function getPdfMetadata(fileId: string): PdfMetadata | undefined {
  const stmt = db.prepare('SELECT * FROM pdf_metadata WHERE file_id = ?');
  return stmt.get(fileId) as PdfMetadata | undefined;
}

// Document chunk functions
export interface DocumentChunk {
  id: string;
  documentId: string;
  pageNumber: number;
  chunkIndex: number;
  content: string;
  contentType: string;
  tokenCount: number;
  importance: number;
  createdAt: number;
}

export function saveDocumentChunk(data: {
  documentId: string;
  pageNumber: number;
  chunkIndex: number;
  content: string;
  contentType?: string;
  tokenCount?: number;
  importance?: number;
}): DocumentChunk | null {
  try {
    const id = uuidv4();
    const now = Math.floor(Date.now() / 1000);
    
    // Use a transaction to ensure data consistency
    db.exec('BEGIN TRANSACTION');
    
    // Create a compound key to check for duplicates
    const checkStmt = db.prepare(`
      SELECT id FROM document_chunks 
      WHERE document_id = ? AND page_number = ? AND chunk_index = ?
    `);
    
    const existingChunk = checkStmt.get(data.documentId, data.pageNumber, data.chunkIndex);
    
    let chunkId = id;
    
    if (existingChunk) {
      // Update instead of insert to avoid constraint errors
      chunkId = existingChunk.id;
      const updateStmt = db.prepare(`
        UPDATE document_chunks 
        SET content = ?, content_type = ?, token_count = ?, importance = ?
        WHERE id = ?
      `);
      
      updateStmt.run(
        data.content,
        data.contentType || 'text',
        data.tokenCount || 0,
        data.importance || 0.5,
        chunkId
      );
      console.log(`Updated existing chunk ${chunkId} for document ${data.documentId}, page ${data.pageNumber}, index ${data.chunkIndex}`);
    } else {
      // Insert new record
      const insertStmt = db.prepare(`
        INSERT INTO document_chunks (
          id, document_id, page_number, chunk_index, 
          content, content_type, token_count, importance, created_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
      `);
      
      insertStmt.run(
        chunkId,
        data.documentId,
        data.pageNumber,
        data.chunkIndex,
        data.content,
        data.contentType || 'text',
        data.tokenCount || 0,
        data.importance || 0.5,
        now
      );
      console.log(`Inserted new chunk ${chunkId} for document ${data.documentId}, page ${data.pageNumber}, index ${data.chunkIndex}`);
    }
    
    // The FTS update is handled by triggers, so we don't need to manually insert into FTS
    
    // Commit the transaction
    db.exec('COMMIT');
    
    // Return the record
    const getStmt = db.prepare(`SELECT * FROM document_chunks WHERE id = ?`);
    return getStmt.get(chunkId) as DocumentChunk;
  } catch (error) {
    // If anything goes wrong, roll back
    try {
      db.exec('ROLLBACK');
    } catch (rollbackError) {
      console.error('Error rolling back transaction:', rollbackError);
    }
    
    console.error('Error saving document chunk:', error);
    return null;
  }
}

export function getDocumentChunks(documentId: string): DocumentChunk[] {
  const stmt = db.prepare(`
    SELECT * FROM document_chunks 
    WHERE document_id = ? 
    ORDER BY page_number, chunk_index
  `);
  
  return stmt.all(documentId) as DocumentChunk[];
}

export function getDocumentChunksByDocumentId(documentId: string): DocumentChunk[] {
  const stmt = db.prepare(`
    SELECT * FROM document_chunks 
    WHERE document_id = ?
    ORDER BY page_number ASC, chunk_index ASC
  `);
  
  return stmt.all(documentId) as DocumentChunk[];
}

/**
 * Delete all chunks for a specific document
 */
export function deleteDocumentChunks(documentId: string): void {
  console.log(`Deleting chunks for document: ${documentId}`);
  const stmt = db.prepare('DELETE FROM document_chunks WHERE document_id = ?');
  stmt.run(documentId);
  console.log(`Deleted chunks for document: ${documentId}`);
}

/**
 * Search for document chunks using full-text search
 */
export function searchDocumentChunks(query: string, limit: number = 20): {
  chunk: DocumentChunk,
  fileInfo: { id: string; filename: string; original_filename: string; }
}[] {
  // Use FTS5 to search document chunks
  const stmt = db.prepare(`
    SELECT 
      dc.id, dc.document_id, dc.page_number, dc.chunk_index, 
      dc.content, dc.content_type, dc.token_count, dc.importance, dc.created_at,
      f.id as file_id, f.filename, f.original_filename
    FROM document_chunks_fts fts
    JOIN document_chunks dc ON fts.rowid = dc.rowid
    JOIN files f ON dc.document_id = f.id
    WHERE fts.content MATCH ?
    ORDER BY rank
    LIMIT ?
  `);
  
  const results = stmt.all(query, limit);
  
  return results.map((row: any) => ({
    chunk: {
      id: row.id,
      documentId: row.document_id,
      pageNumber: row.page_number,
      chunkIndex: row.chunk_index,
      content: row.content,
      contentType: row.content_type,
      tokenCount: row.token_count,
      importance: row.importance,
      createdAt: row.created_at
    },
    fileInfo: {
      id: row.file_id,
      filename: row.filename,
      original_filename: row.original_filename
    }
  }));
}

// Settings type
export interface Setting {
  id: string;
  user_id?: string;
  key: string;
  value: string;
  created_at: number;
  updated_at: number;
}

// Settings functions
export function saveSetting(data: { userId?: string; key: string; value: string }): Setting {
  // Check if setting already exists
  const existing = getSetting(data.key, data.userId);
  
  if (existing) {
    // Update existing setting
    const stmt = db.prepare(`
      UPDATE settings
      SET value = ?, updated_at = unixepoch()
      WHERE id = ?
    `);
    
    stmt.run(data.value, existing.id);
    return getSettingById(existing.id) as Setting;
  } else {
    // Insert new setting
    const stmt = db.prepare(`
      INSERT INTO settings (id, user_id, key, value, created_at, updated_at)
      VALUES (?, ?, ?, ?, unixepoch(), unixepoch())
    `);
    
    const id = uuidv4();
    stmt.run(id, data.userId || null, data.key, data.value);
    return getSettingById(id) as Setting;
  }
}

export function getSettingById(id: string): Setting | undefined {
  const stmt = db.prepare('SELECT * FROM settings WHERE id = ?');
  return stmt.get(id) as Setting | undefined;
}

export function getSetting(key: string, userId?: string): Setting | undefined {
  let stmt;
  if (userId) {
    stmt = db.prepare('SELECT * FROM settings WHERE key = ? AND user_id = ?');
    return stmt.get(key, userId) as Setting | undefined;
  } else {
    stmt = db.prepare('SELECT * FROM settings WHERE key = ? AND user_id IS NULL');
    return stmt.get(key) as Setting | undefined;
  }
}

export function getAllSettings(userId?: string) {
  let stmt;
  if (userId) {
    stmt = db.prepare('SELECT * FROM settings WHERE user_id = ?');
    return stmt.all(userId);
  } else {
    stmt = db.prepare('SELECT * FROM settings WHERE user_id IS NULL');
    return stmt.all();
  }
}

export function deleteSetting(id: string) {
  const stmt = db.prepare('DELETE FROM settings WHERE id = ?');
  return stmt.run(id);
}

// Export the database instance
export { db };



================
File: lib/pdf/processor.ts
================
import { PdfMetadataExtraction } from './types';
import { uploadFileToPythonBackend } from '../python-backend';
import path from 'path';

/**
 * Processes a PDF file by delegating to the Python backend
 * This is a wrapper function that maintains the same interface as the old processPdf
 * but delegates the actual processing to the Python backend
 */
export async function processPdf(fileId: string, filePath: string): Promise<PdfMetadataExtraction> {
  // No longer needed since backend handles processing
  return {
    id: fileId,
    filename: path.basename(filePath),
    topics: [],
    title: '',
    author: '',
    subject: '',
    keywords: '',
    creator: '',
    producer: '',
    pageCount: 0,
    creationDate: new Date().toISOString(),
    modificationDate: new Date().toISOString(),
    file_size: 0,
    language: 'en',
    summary: '',
    documentType: 'pdf',
    table_count: 0,
    aiEnhanced: false,
    needsReview: false
  };
}

================
File: lib/pdf/types.ts
================
// lib/pdf/types.ts
export interface PdfMetadataExtraction {
    id?: string;
    filename?: string;
    title: string;
    author: string;
    subject: string;
    keywords: string;
    creator: string;
    producer: string;
    pageCount: number;
    creationDate: string;
    modificationDate: string;
    file_creation_date?: string | Date;
    file_modification_date?: string | Date;
    file_size?: number;
    language?: string;
    
    // Additional fields
    summary: string;
    documentType: string;
    topics: string[];
    table_count?: number;
    
    // Tracking fields
    aiEnhanced: boolean;
    needsReview: boolean;
  }
  
  export interface PdfExtractionResult {
    metadata: PdfMetadataExtraction;
    fullText: string;
    pageTexts: string[];
  }
  
  export interface DocumentChunk {
    documentId: string;
    pageNumber: number;
    chunkIndex: number;
    content: string;
    contentType: string;
    tokenCount: number;
  }

================
File: lib/python-backend.ts
================
// File: lib/python-backend.ts
const API_ROUTE = '/api/python-backend';

/**
 * Upload a file to the Python backend
 */
export async function uploadFileToPythonBackend(
  file: File,
  metadata?: { title?: string; author?: string }
): Promise<{
  id: string;
  status: string;
  filename: string;
  title: string;
  page_count: number;
  chunk_count: number;
}> {
  const formData = new FormData();
  formData.append('file', file);
  
  if (metadata?.title) {
    formData.append('title', metadata.title);
  }
  
  if (metadata?.author) {
    formData.append('author', metadata.author);
  }
  
  const response = await fetch(`${API_ROUTE}?endpoint=upload_file`, {
    method: 'POST',
    body: formData,
  });
  
  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.detail || 'Failed to upload file to Python backend');
  }
  
  return await response.json();
}

/**
 * Search documents in the Python backend
 */
/**
 * Search documents in the Python backend
 */
export async function searchDocumentsInPythonBackend(
  query: string,
  options?: {
    document_id?: string;
    limit?: number;
    offset?: number;
    search_type?: 'fulltext' | 'vector' | 'hybrid';
    vector_weight?: number;
    text_weight?: number;
    filters?: Record<string, any>;
  }
): Promise<{
  results: any[];
  total: number;
  query: string;
}> {
  const response = await fetch('/api/search', {  // Changed from `${API_ROUTE}/search`
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      query,
      documentId: options?.document_id,  // Match /api/search expectation
      limit: options?.limit || 10,
      searchType: options?.search_type || 'hybrid',  // Match /api/search expectation
      // Note: vector_weight, text_weight, offset, and filters aren't supported by /api/search currently
    }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error || 'Failed to search documents in Python backend');
  }

  const data = await response.json();
  return {
    results: data.results,
    total: data.count,
    query: data.query,
  };
}
/**
 * Query documents with LLM in the Python backend
 */
// Add this function to pass the API key to the backend
export async function queryDocumentWithLLM(
  query: string,
  document_id?: string,
  chat_mode: string = 'document'
): Promise<{
  response: string;
  context: string;
  mode: string;
}> {
  // Get API key from localStorage
  const apiKey = typeof window !== 'undefined' ? localStorage.getItem("openai_api_key") : null;
  
  const PYTHON_BACKEND_URL = process.env.NEXT_PUBLIC_PYTHON_BACKEND_URL || 'http://localhost:8000';
  
  try {
    const response = await fetch(`${PYTHON_BACKEND_URL}/query`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        query,
        document_id,
        chat_mode,
        api_key: apiKey, // Pass the API key with the request
      }),
      // Add a timeout to prevent hanging requests
      signal: AbortSignal.timeout(30000), // 30 second timeout
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.detail || 'Failed to query document with LLM');
    }
    
    return await response.json();
  } catch (error) {
    console.error("Error querying document with LLM:", error);
    throw error;
  }
}

/**
 * List documents from the Python backend
 */
export async function listDocumentsFromPythonBackend(
  options?: {
    limit?: number;
    offset?: number;
    search?: string;
  }
): Promise<{
  total: number;
  documents: {
    id: string;
    title: string;
    author: string;
    creation_date: string | null;
    page_count: number;
    file_size: number;
    document_type: string;
    filename: string;
  }[];
}> {
  const searchParams = new URLSearchParams();
  searchParams.append('endpoint', 'documents');
  
  if (options?.limit) {
    searchParams.append('limit', options.limit.toString());
  }
  
  if (options?.offset) {
    searchParams.append('offset', options.offset.toString());
  }
  
  if (options?.search) {
    searchParams.append('search', options.search);
  }
  const response = await fetch(`${API_ROUTE}?${searchParams.toString()}`);
  
  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.detail || 'Failed to list documents from Python backend');
  }
  
  return await response.json();
}

/**
 * Get documents from the Python backend
 */
export async function getDocumentsFromPythonBackend(id?: string) {
  try {
    // Base URL for the Python backend API
    const baseUrl = "/api/python-backend";
    
    // If an ID is provided, get a specific document
    if (id) {
      const response = await fetch(`${baseUrl}?endpoint=documents/${id}`);
      
      if (!response.ok) {
        throw new Error(`Failed to fetch document: ${response.statusText}`);
      }
      
      return await response.json();
    }
    
    // Otherwise, get all documents
    const response = await fetch(`${baseUrl}?endpoint=documents`);
    
    if (!response.ok) {
      throw new Error(`Failed to fetch documents: ${response.statusText}`);
    }
    
    return await response.json();
  } catch (error) {
    console.error("Error in Python backend utility:", error);
    throw error;
  }
}
  /**
   * Get document details from the Python backend
   */
  export async function getDocumentFromPythonBackend(
    document_id: string
  ): Promise<{
    id: string;
    title: string;
    author: string;
    creation_date: string | null;
    modification_date: string | null;
    page_count: number;
    file_size: number;
    document_type: string;
    filename: string;
    language: string;
    chunk_count: number;
    table_count: number;
    topics: string[];
  }> {
    const searchParams = new URLSearchParams();
    searchParams.append('endpoint', `document/${document_id}`);
    
    const response = await fetch(`${API_ROUTE}?${searchParams.toString()}`);
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.detail || 'Failed to get document from Python backend');
    }
    
    return await response.json();
  }
  
  /**
   * Delete a document from the Python backend
   */
  export async function deleteDocumentFromPythonBackend(documentId: string) {
    const PYTHON_BACKEND_URL = process.env.NEXT_PUBLIC_PYTHON_BACKEND_URL || 'http://localhost:8000';
    
    try {
      const response = await fetch(`${PYTHON_BACKEND_URL}/document/${documentId}`, {
        method: 'DELETE',
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.detail || 'Failed to delete document');
      }
      
      return true;
    } catch (error) {
      console.error("Error deleting document:", error);
      throw error;
    }
  }

export async function searchDocuments(query: string, searchType: string) {
  const response = await fetch('/api/search', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({ query, searchType })
  });
  return await response.json();
}

================
File: lib/utils.ts
================
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function formatBytes(bytes: number, decimals = 2) {
  if (bytes === 0) return '0 Bytes';

  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];

  const i = Math.floor(Math.log(bytes) / Math.log(k));

  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}

export function getFileExtension(filename: string): string {
  return filename.slice(((filename.lastIndexOf(".") - 1) >>> 0) + 2);
}

export function isValidPdf(file: File): boolean {
  return file.type === 'application/pdf';
}

export function generateId(): string {
  return Math.random().toString(36).substring(2, 15) + 
         Math.random().toString(36).substring(2, 15);
}

export function truncateFilename(filename: string, maxLength = 25): string {
  if (filename.length <= maxLength) return filename;
  
  const extension = getFileExtension(filename);
  const nameWithoutExtension = filename.slice(0, filename.lastIndexOf('.'));
  
  const truncatedName = nameWithoutExtension.slice(0, maxLength - extension.length - 3) + '...';
  return `${truncatedName}.${extension}`;
}

/**
 * Estimates the number of tokens in a text string
 * This is a rough approximation - about 4 chars per token for English text
 */
export function estimateTokenCount(text: string): number {
  return Math.ceil(text.length / 4);
}

================
File: next.config.js
================
// File: next.config.js (update)
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  env: {
    DB_CONNECTION: process.env.DB_CONNECTION,
  },
}

module.exports = nextConfig


================
File: python-backend/api.py
================
# api.py
import os
import tempfile
import shutil
import traceback
from fastapi import FastAPI, HTTPException, File, UploadFile, Form, Query, Request
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional
from db import get_db_session, Document, DocumentChunk, DocumentPage, DocumentEntity, DocumentRelationship, Session, store_data
from pdf_processing import ingest_pdf
from llm_helper import query_llm, build_context, generate_response_with_context, generate_response, format_search_results, generate_advanced_analysis
from search import fulltext_search, vector_search, hybrid_search
from config import logger, CONFIG
from file_storage import save_uploaded_file, delete_file, get_file_path
import uuid

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

class UploadRequest(BaseModel):
    file_path: str

# Update the QueryRequest class to include api_key
class QueryRequest(BaseModel):
    query: str
    document_id: Optional[str] = None
    api_key: Optional[str] = None
    chat_mode: Optional[str] = "document"

class SearchRequest(BaseModel):
    query: str
    document_id: Optional[str] = None
    limit: int = 10
    offset: int = 0
    search_type: str = "hybrid"
    vector_weight: float = 0.65
    text_weight: float = 0.35
    filters: dict = {}

@app.post("/upload")
async def upload_file(
    file: UploadFile = File(..., description="PDF file to upload"),
    title: Optional[str] = Form(None, alias="docTitle"),
    author: Optional[str] = Form(None, alias="docAuthor")
):
    if not file.filename.lower().endswith('.pdf'):
        raise HTTPException(status_code=400, detail="Only PDF files are supported")
    
    file_path = None
    file_id = None
    
    try:
        logger.info(f"Saving uploaded file: {file.filename}")
        file_path, file_id = save_uploaded_file(file)
        logger.info(f"File saved successfully at: {file_path}")
        
        logger.info(f"Processing PDF: {file_path}")
        metadata, chunks, pages, entities, relationships = ingest_pdf(file_path)
        logger.info(f"PDF processed successfully: {len(chunks)} chunks, {len(pages)} pages")
        
        # Check for existing document
        with get_db_session() as session:
            existing_doc = session.query(Document).filter(Document.id == metadata["id"]).first()
            if existing_doc:
                logger.info(f"Document with ID {metadata['id']} already exists, skipping storage")
                delete_file(file_id)
                return {
                    "id": str(existing_doc.id),
                    "status": "exists",
                    "filename": file.filename,
                    "title": existing_doc.title,
                    "page_count": existing_doc.page_count,
                    "chunk_count": session.query(DocumentChunk).filter(DocumentChunk.document_id == existing_doc.id).count()
                }
        
        # Override metadata if provided
        if title:
            metadata["title"] = title
        if author:
            metadata["author"] = author
                
        # Store in database
        logger.info("Storing document in database")
        with get_db_session() as session:
            doc = Document(**metadata)
            chunk_objects = [DocumentChunk(**chunk) for chunk in chunks]
            page_objects = [DocumentPage(**page) for page in pages]
            
            # Correctly map entity fields
            entity_objects = [
                DocumentEntity(
                    id=entity["id"],  # Use provided UUID
                    document_id=metadata["id"],
                    type=entity["type"],
                    name=entity["name"],
                    normalized_name=entity["normalized_name"],
                    occurrences=entity["occurrences"],
                    importance=entity.get("importance", 0.0),
                    description=entity.get("description", "")
                ) for entity in entities
            ]
            
            # Correctly map relationship fields
            relationship_objects = [
                DocumentRelationship(
                    id=rel["id"],  # Use provided UUID
                    document_id=metadata["id"],
                    source_entity_id=rel["source_entity_id"],  # Corrected from "source_id"
                    target_entity_id=rel["target_entity_id"],  # Corrected from "target_id"
                    type=rel["type"],
                    confidence=rel.get("confidence", 0.0),
                    description=rel.get("description", ""),
                    chunk_ids=rel.get("chunk_ids", [])
                ) for rel in relationships
            ]
            
            store_data(session, [doc] + chunk_objects + page_objects + entity_objects + relationship_objects)
        
        logger.info(f"Document stored successfully with ID: {metadata['id']}")
        return {
            "id": str(metadata["id"]),
            "status": "success",
            "filename": file.filename,
            "title": metadata["title"],
            "page_count": metadata["page_count"],
            "chunk_count": len(chunks)
        }
    except Exception as e:
        logger.error(f"Error processing PDF: {e}")
        logger.debug(traceback.format_exc())
        
        if file_id:
            try:
                delete_file(file_id)
                logger.info(f"Deleted file {file_id} due to processing error")
            except Exception as del_error:
                logger.error(f"Failed to delete file after processing error: {del_error}")
        
        raise HTTPException(status_code=500, detail=f"PDF processing failed: {str(e)}")
    finally:
        pass

@app.get("/document/{document_id}")
async def get_document(document_id: str):
    try:
        with get_db_session() as session:
            # Add validation for UUID format
            try:
                doc_id = uuid.UUID(document_id)
            except ValueError:
                raise HTTPException(status_code=400, detail="Invalid document ID format")
            
            document = session.query(Document).filter(Document.id == doc_id).first()
            
            if not document:
                raise HTTPException(status_code=404, detail="Document not found")
            
            # Get related entities and relationships
            entities = session.query(DocumentEntity).filter(
                DocumentEntity.document_id == doc_id
            ).all()
            
            relationships = session.query(DocumentRelationship).filter(
                DocumentRelationship.document_id == doc_id
            ).all()
            
            # Extract metadata from document and related entities
            metadata = {
                "summary": document.summary,
                "document_type": document.document_type,
                "topics": [entity.name for entity in entities 
                          if entity.type == "topic"],
                "entities": {
                    "people": [entity.name for entity in entities 
                              if entity.type == "person"],
                    "organizations": [entity.name for entity in entities 
                                    if entity.type == "organization"],
                    "locations": [entity.name for entity in entities 
                                if entity.type == "location"]
                },
                "relationships": [
                    {
                        "source": session.get(DocumentEntity, rel.source_entity_id).name,
                        "target": session.get(DocumentEntity, rel.target_entity_id).name,
                        "type": rel.type
                    } for rel in relationships
                ]
            }
            
            return {
                "id": str(document.id),
                "filename": document.filename,
                "title": document.title,
                "author": document.author or "Unknown",
                "page_count": document.page_count or 0,
                "creation_date": document.creation_date.isoformat() if document.creation_date else None,
                "modification_date": document.modification_date.isoformat() if document.modification_date else None,
                "document_type": document.document_type or "Uncategorized",
                "topics": document.topics if document.topics else []
            }
    except Exception as e:
        logger.error(f"Document retrieval failed: {str(e)}")
        raise HTTPException(status_code=500, detail="Internal server error")

@app.get("/documents")
async def list_documents():
    try:
        with get_db_session() as session:
            documents = session.query(Document).order_by(Document.creation_date.desc()).all()
            return [
                {
                    "id": str(doc.id),
                    "filename": doc.filename,
                    "title": doc.title,
                    "author": doc.author,
                    "page_count": doc.page_count,
                    "creation_date": doc.creation_date.isoformat() if doc.creation_date else None
                }
                for doc in documents
            ]
    except Exception as e:
        logger.error(f"Document list failed: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@app.delete("/document/{document_id}")
async def delete_document(document_id: str):
    try:
        with get_db_session() as session:
            # Delete related chunks and pages first
            session.query(DocumentChunk).filter(DocumentChunk.document_id == document_id).delete()
            session.query(DocumentPage).filter(DocumentPage.document_id == document_id).delete()
            
            # Delete main document
            document = session.query(Document).filter(Document.id == uuid.UUID(document_id)).first()
            if not document:
                raise HTTPException(status_code=404, detail="Document not found")
                
            session.delete(document)
            session.commit()
            
            return {"status": "success"}
            
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid document ID format")
    except Exception as e:
        session.rollback()
        logger.error(f"Document deletion failed: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")

@app.post("/search")
async def search_documents(request: SearchRequest):
    try:
        search_type = request.search_type.lower()
        valid_types = ["fulltext", "vector", "hybrid"]
        
        if search_type not in valid_types:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid search type. Valid options: {', '.join(valid_types)}"
            )

        search_func = {
            "fulltext": fulltext_search,
            "vector": vector_search,
            "hybrid": hybrid_search
        }[search_type]

        logger.info(f"Performing {search_type} search with query: '{request.query}'")

        result = search_func(
            query=request.query,
            document_id=request.document_id,
            limit=request.limit,
            offset=request.offset,
            vector_weight=request.vector_weight,
            text_weight=request.text_weight,
            **request.filters
        )

        if "error" in result:
            logger.error(f"Search error: {result['error']}")
            raise HTTPException(status_code=500, detail=result["error"])

        return result

    except ValueError as e:
        logger.error(f"Search value error: {e}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Search failed: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/query")
async def query_document(request: Request):
    data = await request.json()
    query = data.get("query", "")
    document_id = data.get("document_id")
    chat_mode = data.get("chat_mode", "document")  # Default to document mode
    api_key = data.get("api_key")  # Get API key from request
    
    if not query:
        raise HTTPException(status_code=400, detail="Query is required")
    
    try:
        logger.info(f"Processing query in {chat_mode} mode: '{query[:50]}...' with document_id: {document_id}")
        
        # Different handling based on chat mode
        if chat_mode == "document":
            # Existing document chat logic
            try:
                search_results = hybrid_search(query, limit=5, document_id=document_id)
                chunks = search_results.get("results", [])
                logger.info(f"Found {len(chunks)} chunks for document query")
                context = build_context(chunks, query)
            except Exception as search_error:
                logger.error(f"Search error in document mode: {search_error}")
                context = "Error retrieving document context. Proceeding with general response."
                chunks = []
            
            # Call LLM with document context and API key
            response = await generate_response_with_context(query, context, api_key)
            
        elif chat_mode == "general":
            # General chat without document context
            response = await generate_response(query, api_key)
            context = ""
            
        elif chat_mode == "search":
            # Search mode
            try:
                search_results = hybrid_search(query, limit=10)
                chunks = search_results.get("results", [])
                logger.info(f"Found {len(chunks)} chunks for search query")
                context = build_context(chunks, query)
                response = format_search_results(chunks, query)
            except Exception as search_error:
                logger.error(f"Search error in search mode: {search_error}")
                response = "Sorry, I encountered an error while searching the documents."
                context = ""
                chunks = []
            
        elif chat_mode == "advanced":
            # Advanced document analysis
            try:
                search_results = hybrid_search(query, limit=8, document_id=document_id)
                chunks = search_results.get("results", [])
                logger.info(f"Found {len(chunks)} chunks for advanced analysis")
                context = build_context(chunks, query)
            except Exception as search_error:
                logger.error(f"Search error in advanced mode: {search_error}")
                context = "Error retrieving document context. Proceeding with general response."
                chunks = []
            
            # Call LLM with advanced analysis prompt and API key
            response = await generate_advanced_analysis(query, context, api_key)
            
        else:
            raise HTTPException(status_code=400, detail=f"Unsupported chat mode: {chat_mode}")
        
        logger.info(f"Successfully generated response for query in {chat_mode} mode")
        return {
            "response": response,
            "context": context,
            "mode": chat_mode
        }
    except Exception as e:
        logger.error(f"Query failed: {e}")
        logger.error(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"Query failed: {str(e)}")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)

================
File: python-backend/app.py
================
# app.py
from fastapi import FastAPI
from api import app as api_app
from config import CONFIG, logger
from db import get_db_session
from sqlalchemy import text

app = FastAPI(
    title="Simple PDF Backend with LLM",
    description="Basic backend for PDF processing and LLM queries",
    version="1.0.0"
)

app.mount("", api_app)

@app.on_event("startup")
async def startup_event():
    try:
        # Check database connection
        logger.info("Checking database connection...")
        with get_db_session() as session:
            session.execute(text("SELECT 1"))
            logger.info("Database connection successful")
        
        logger.info(f"Starting server on port {CONFIG['API_PORT']}")
    except Exception as e:
        logger.error(f"Startup failed: {e}")
        raise

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=CONFIG["API_PORT"])

================
File: python-backend/config.py
================
# config.py
import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

CONFIG = {
    "DB_CONNECTION": os.getenv("DB_CONNECTION", "postgresql://postgres:redknightS3@localhost:5432/pdf_db"),
    "OPENAI_API_KEY": os.getenv("OPENAI_API_KEY", "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"),  # Changed from LLM_API_KEY
    "GEMINI_API_KEY": os.getenv("GEMINI_API_KEY", "AIzaSyBYlkT1PSEg42qfAwTcZ7KvUQBScGd8vfw"),
    "LLM_API_URL": os.getenv("LLM_API_URL", "https://api.openai.com/v1"),  # Updated to OpenAI URL
    "CHUNK_SIZE": int(os.getenv("CHUNK_SIZE", 500)),
    "EMBEDDING_MODEL": "nomic-ai/nomic-embed-text-v2-moe",
    "SUMMARIZATION_MODEL": "Falconsai/text_summarization",
    "USE_GEMINI_ENHANCEMENT" : True,  # Default to False, set to True to enable
    "NLP_MODEL": "xx_ent_wiki_sm",
    "LOG_LEVEL": os.getenv("LOG_LEVEL", "INFO"),
    "API_PORT": int(os.getenv("API_PORT", 8000))
}

import logging
logging.basicConfig(
    level=getattr(logging, CONFIG["LOG_LEVEL"]),
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

================
File: python-backend/db.py
================
# db.py
import uuid
from sqlalchemy import create_engine, Column, String, Integer, Float, DateTime, ForeignKey, JSON, ARRAY, text, Boolean
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, scoped_session
from sqlalchemy.dialects.postgresql import UUID
from pgvector.sqlalchemy import Vector
import logging
import datetime
from config import CONFIG, logger
from utils import parse_pdf_date

Base = declarative_base()

# Define database models
class Document(Base):
    __tablename__ = 'documents'
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    filename = Column(String)
    title = Column(String)
    author = Column(String)
    creation_date = Column(DateTime)
    modification_date = Column(DateTime)
    file_creation_date = Column(DateTime)
    file_modification_date = Column(DateTime)
    page_count = Column(Integer)
    file_size = Column(Integer)
    language = Column(String)
    summary = Column(String)
    document_type = Column(String)
    topics = Column(ARRAY(String))
    table_count = Column(Integer)

class DocumentPage(Base):
    __tablename__ = 'document_pages'
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    document_id = Column(UUID(as_uuid=True), ForeignKey('documents.id'))
    page_number = Column(Integer)
    has_table = Column(Boolean)

class DocumentChunk(Base):
    __tablename__ = 'document_chunks'
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    document_id = Column(UUID(as_uuid=True), ForeignKey('documents.id'))
    page_number = Column(Integer)
    chunk_index = Column(Integer)
    content = Column(String)
    content_type = Column(String)
    section_path = Column(ARRAY(String))
    embedding = Column(Vector(768))
    token_count = Column(Integer)
    importance = Column(Float)

class DocumentEntity(Base):
    __tablename__ = 'document_entities'
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    document_id = Column(UUID(as_uuid=True), ForeignKey('documents.id'))
    type = Column(String)
    name = Column(String)
    normalized_name = Column(String)
    occurrences = Column(JSON)
    importance = Column(Float)
    description = Column(String)

class DocumentRelationship(Base):
    __tablename__ = 'document_relationships'
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    document_id = Column(UUID(as_uuid=True), ForeignKey('documents.id'))
    source_entity_id = Column(UUID(as_uuid=True))
    target_entity_id = Column(UUID(as_uuid=True))
    type = Column(String)
    confidence = Column(Float)
    description = Column(String)
    chunk_ids = Column(ARRAY(String))

engine = create_engine(CONFIG["DB_CONNECTION"])
try:
    # Create tables if they don't exist
    Base.metadata.create_all(engine)
    logger.info("Database tables created successfully")
except Exception as e:
    logger.error(f"Error creating database tables: {e}")
    raise

Session = sessionmaker(bind=engine)

def get_db_session():
    try:
        session = Session()
        return session
    except Exception as e:
        logger.error(f"Error creating database session: {e}")
        raise

def store_data(session, items):
    try:
        for item in items:
            if isinstance(item, Document):
                if isinstance(item.creation_date, str) and item.creation_date.startswith('D:'):
                    item.creation_date = parse_pdf_date(item.creation_date)
                if isinstance(item.modification_date, str) and item.modification_date.startswith('D:'):
                    item.modification_date = parse_pdf_date(item.modification_date)
            session.add(item)
        session.commit()
        logger.info("Data stored successfully")
    except Exception as e:
        session.rollback()
        logger.error(f"Failed to store data: {e}")
        raise

__all__ = [
    'get_db_session', 
    'Document', 
    'DocumentChunk', 
    'DocumentPage',
    'DocumentEntity',
    'DocumentRelationship',
    'Session'
]

================
File: python-backend/file_storage.py
================
# file_storage.py
import os
import shutil
import uuid
import traceback
from typing import Optional, Tuple
from fastapi import UploadFile
from config import CONFIG, logger

# Define storage directory
UPLOAD_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "uploads")

# Create upload directory if it doesn't exist
os.makedirs(UPLOAD_DIR, exist_ok=True)

def save_uploaded_file(file: UploadFile, document_id: Optional[str] = None) -> Tuple[str, str]:
    """
    Save an uploaded file to the storage directory.
    
    Args:
        file: The uploaded file
        document_id: Optional document ID to use in filename
        
    Returns:
        Tuple of (file_path, file_id)
    """
    try:
        # Generate a unique ID for the file if not provided
        file_id = document_id or str(uuid.uuid4())
        
        # Get file extension
        _, ext = os.path.splitext(file.filename)
        if not ext:
            ext = ".pdf"  # Default to PDF extension
            
        # Create filename
        filename = f"{file_id}{ext}"
        file_path = os.path.join(UPLOAD_DIR, filename)
        
        # Read the file content into memory first to avoid partial writes
        file.file.seek(0)
        content = file.file.read()
        
        # Check if it's a valid PDF (simple header check)
        if ext.lower() == '.pdf':
            if not content.startswith(b'%PDF-'):
                logger.warning(f"File does not start with PDF header: {file.filename}")
                # We'll still save it, but log the warning
            
            # Additional validation could be added here
            
        # Save the file
        with open(file_path, "wb") as buffer:
            buffer.write(content)
        
        logger.info(f"File saved successfully: {file_path} ({len(content)} bytes)")
        return file_path, file_id
    except Exception as e:
        logger.error(f"Error saving file: {e}")
        logger.debug(traceback.format_exc())
        raise

def delete_file(document_id: str) -> bool:
    """
    Delete a file from storage.
    
    Args:
        document_id: The document ID
        
    Returns:
        True if successful, False otherwise
    """
    try:
        # Look for files with this document ID
        for filename in os.listdir(UPLOAD_DIR):
            if filename.startswith(document_id):
                file_path = os.path.join(UPLOAD_DIR, filename)
                os.remove(file_path)
                logger.info(f"Deleted file: {file_path}")
                return True
        
        logger.warning(f"No file found for document ID: {document_id}")
        return False
    except Exception as e:
        logger.error(f"Failed to delete file: {e}")
        return False

def get_file_path(document_id: str) -> Optional[str]:
    """
    Get the file path for a document ID.
    
    Args:
        document_id: The document ID
        
    Returns:
        The file path if found, None otherwise
    """
    try:
        for filename in os.listdir(UPLOAD_DIR):
            if filename.startswith(document_id):
                return os.path.join(UPLOAD_DIR, filename)
        
        return None
    except Exception as e:
        logger.error(f"Failed to get file path: {e}")
        return None

================
File: python-backend/init_db.py
================
import psycopg2
from config import CONFIG, logger

def initialize_database():
    """Initialize the database with the pgvector extension."""
    conn_string = CONFIG["DB_CONNECTION"]
    
    try:
        # Connect to the database
        logger.info("Connecting to database...")
        conn = psycopg2.connect(conn_string)
        conn.autocommit = True
        cursor = conn.cursor()
        
        # Create the pgvector extension
        logger.info("Creating pgvector extension...")
        cursor.execute("CREATE EXTENSION IF NOT EXISTS vector;")
        
        # Verify the extension was created
        cursor.execute("SELECT extname FROM pg_extension WHERE extname = 'vector';")
        result = cursor.fetchone()
        
        if result and result[0] == 'vector':
            logger.info("pgvector extension successfully installed")
        else:
            logger.error("Failed to install pgvector extension")
            
        # Close the connection
        cursor.close()
        conn.close()
        logger.info("Database initialization completed")
        
    except Exception as e:
        logger.error(f"Error initializing database: {e}")
        raise

if __name__ == "__main__":
    initialize_database()

================
File: python-backend/installation.md
================
- create virtual environment
- python -m venv venv
- source venv/bin/activate
- pip install -r requirements.txt
- # From your activated virtual environment
- python -m ensurepip --default-pip
- python -m spacy download xx_ent_wiki_sm

================
File: python-backend/llm_helper.py
================
# llm_helper.py
import aiohttp
import json
from config import CONFIG, logger

async def query_llm(prompt, api_key=None):
    """Query the LLM with a prompt and return the response."""
    try:
        # Use provided API key or fall back to config
        key_to_use = api_key or CONFIG.get('OPENAI_API_KEY') or CONFIG.get('LLM_API_KEY')
        
        if not key_to_use or key_to_use in ["", "your-llm-key"]:
            logger.warning("No valid API key provided for LLM query")
            return "Error: No valid API key provided. Please configure your API key in settings."
            
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {key_to_use}"
        }
        
        payload = {
            "model": "gpt-4o",  # Updated to use GPT-4o by default
            "messages": [
                {"role": "system", "content": "You are a helpful assistant that answers questions about PDF documents."},
                {"role": "user", "content": prompt}
            ],
            "temperature": 0.7,
            "max_tokens": 1000
        }
        
        logger.info(f"Sending request to OpenAI API with prompt length: {len(prompt)}")
        
        async with aiohttp.ClientSession() as session:
            try:
                async with session.post("https://api.openai.com/v1/chat/completions", 
                                       headers=headers, 
                                       json=payload,
                                       timeout=60) as response:  # Increased timeout
                    if response.status != 200:
                        error_text = await response.text()
                        logger.error(f"OpenAI API error: Status {response.status}, {error_text}")
                        return f"I'm sorry, I couldn't process your request due to an API error (Status {response.status})."
                    
                    data = await response.json()
                    return data["choices"][0]["message"]["content"]
            except aiohttp.ClientError as ce:
                logger.error(f"Connection error with OpenAI API: {ce}")
                return "I'm sorry, I encountered a connection error while processing your request. Please try again later."
    except Exception as e:
        logger.error(f"Error querying OpenAI: {e}")
        logger.error(traceback.format_exc())
        return "I'm sorry, I encountered an error while processing your request."

def build_context(chunks, query):
    """Build context from document chunks for the LLM."""
    if not chunks:
        return "No relevant information found in the document."
    
    # Format chunks into a context string
    context = "Here are the relevant sections from the document:\n\n"
    
    for i, chunk in enumerate(chunks):
        content = chunk.get("content", "")
        document_title = chunk.get("document_title", "Document")
        page_number = chunk.get("page_number", "Unknown")
        
        context += f"[Section {i+1} from {document_title}, Page {page_number}]\n{content}\n\n"
    
    return context

# Add the missing functions referenced in query_document

# Update these functions to accept api_key parameter

async def generate_response_with_context(query, context, api_key=None):
    """Generate a response using the LLM with document context."""
    prompt = f"""Please answer the following question based on the provided document context. 
If the answer cannot be found in the context, please say so.

Context:
{context}

Question: {query}

Answer:"""
    
    return await query_llm(prompt, api_key)

async def generate_response(query, api_key=None):
    """Generate a response for general chat without document context."""
    prompt = f"""Please answer the following question to the best of your ability:

Question: {query}

Answer:"""
    
    return await query_llm(prompt, api_key)

async def generate_advanced_analysis(query, context, api_key=None):
    """Generate an advanced analysis of document content."""
    prompt = f"""Please provide a detailed analysis of the document based on the following question.
Include key insights, patterns, and relevant information from the document context.

Context:
{context}

Question for analysis: {query}

Detailed Analysis:"""
    
    return await query_llm(prompt, api_key)

def format_search_results(chunks, query):
    """Format search results for display in the chat."""
    if not chunks:
        return "No results found for your query."
    
    response = f"### Search Results for: '{query}'\n\n"
    
    for i, chunk in enumerate(chunks):
        content = chunk.get("content", "")
        document_title = chunk.get("document_title", "Document")
        page_number = chunk.get("page_number", "Unknown")
        score = chunk.get("score", 0)
        
        # Truncate content if it's too long
        if len(content) > 300:
            content = content[:300] + "..."
        
        response += f"**Result {i+1}** (from {document_title}, Page {page_number})\n"
        response += f"{content}\n\n"
    
    response += f"Found {len(chunks)} results. Ask follow-up questions to learn more about specific results."
    
    return response

================
File: python-backend/pdf_processing.py
================
# pdf_processing.py
import fitz
import uuid
import os
import datetime
import tiktoken
from sentence_transformers import SentenceTransformer
from config import CONFIG, logger
from utils import parse_pdf_date
import pymupdf4llm
from PyPDF2 import PdfReader
import io
import traceback
import re
import spacy
from collections import Counter
from transformers import pipeline, AutoTokenizer, AutoModelForSequenceClassification
import google.generativeai as genai
from typing import Dict, Any, Tuple
import json
import time
from db import get_db_session, Document, DocumentChunk, DocumentPage
from collections import defaultdict
from sqlalchemy import Table, Column, Integer, String, Float, ForeignKey, text

# Initialize tokenizers and models
tokenizer = tiktoken.get_encoding("cl100k_base")
embedder = SentenceTransformer(CONFIG["EMBEDDING_MODEL"], trust_remote_code=True)
nlp = spacy.load("xx_ent_wiki_sm")
summarizer = pipeline("summarization", model="Falconsai/text_summarization")

llm_tokenizer = AutoTokenizer.from_pretrained("nlpaueb/legal-bert-small-uncased")
llm_model = AutoModelForSequenceClassification.from_pretrained(
    "nlpaueb/legal-bert-small-uncased",
    num_labels=3
)
llm_classifier = pipeline("text-classification", model=llm_model, tokenizer=llm_tokenizer, device=-1)

def extract_title_author_with_llm(text) -> Tuple[str, str, float, float]:
    try:
        candidates = [line.strip() for line in text.split('\n') if line.strip()]
        if not candidates:
            return "Unknown", "Unknown", 0.0, 0.0

        title = "Unknown"
        author = "Unknown"
        max_title_score = 0.0
        max_author_score = 0.0

        for candidate in candidates[:20]:
            if len(candidate) > 500:
                candidate = candidate[:500]
            result = llm_classifier(candidate)[0]
            label = result["label"]
            score = result["score"]

            if label == "LABEL_0":  # Title
                if score > max_title_score and len(candidate) > 5:
                    title = candidate
                    max_title_score = score
            elif label == "LABEL_1":  # Author
                if score > max_author_score and len(candidate) > 3:
                    author = candidate
                    max_author_score = score

        title = title.replace('\x00', '').strip()
        author = author.replace('\x00', '').strip()
        logger.info(f"LLM extracted - Title: '{title}' (score: {max_title_score:.2f}), Author: '{author}' (score: {max_author_score:.2f})")
        return title, author, max_title_score, max_author_score
    except Exception as e:
        logger.warning(f"LLM title/author extraction failed: {e}")
        return "Unknown", "Unknown", 0.0, 0.0

def enhance_metadata_gemini(doc: Dict[str, Any], pages_text: str, title_score: float, author_score: float) -> Dict[str, Any]:
    try:
        use_gemini = CONFIG.get("USE_GEMINI_ENHANCEMENT", False)
        if not use_gemini or (title_score >= 0.5 and author_score >= 0.5):
            logger.info(f"Skipping Gemini enhancement: USE_GEMINI_ENHANCEMENT={use_gemini}, title_score={title_score:.2f}, author_score={author_score:.2f}")
            return doc

        if not CONFIG.get("GEMINI_API_KEY"):
            logger.warning("Gemini API key missing in config")
            return doc
        
        genai.configure(api_key=CONFIG["GEMINI_API_KEY"])
        model = genai.GenerativeModel("gemini-2.0-flash")
        
        pages_text = pages_text[:4000]
        prompt = f"""Analyze this document structure and content to enhance metadata. Focus on:
        1. Title: Suggest a concise, descriptive title (12 words max)
        2. Author: Extract from headers/footers/signatures
        3. Summary: 3-5 key points in bullet format
        4. Topics: 5-7 specific keywords/tags

        Return ONLY valid JSON format:
        {{
            "title": string,
            "author": string,
            "summary": string[],
            "topics": string[]
        }}

        Document excerpts:
        {pages_text}

        Current metadata (verify/improve):
        - Title: {doc.get('title')}
        - Author: {doc.get('author')}
        """
        
        for attempt in range(3):
            try:
                response = model.generate_content(prompt)
                raw_response = response.text.strip()
                logger.debug(f"Gemini raw response (attempt {attempt+1}): {raw_response[:500]}...")

                if not raw_response:
                    logger.warning(f"Gemini returned empty response on attempt {attempt+1}")
                    time.sleep(2)
                    continue
                
                if raw_response.startswith('```json'):
                    raw_response = raw_response[7:-3].strip()
                
                enhanced = json.loads(raw_response)
                
                doc["title"] = enhanced.get("title", doc["title"])
                doc["author"] = enhanced.get("author", doc["author"])
                doc["summary"] = " ".join(enhanced.get("summary", []))
                doc["topics"] = list(set(doc["topics"] + enhanced.get("topics", [])))
                
                logger.info(f"Gemini enhanced metadata: {enhanced}")
                return doc
            except json.JSONDecodeError as e:
                logger.warning(f"Gemini returned invalid JSON on attempt {attempt+1}: {e}. Raw response: {raw_response if 'raw_response' in locals() else 'No response'}")
                time.sleep(2)
            except Exception as e:
                logger.warning(f"Gemini attempt {attempt+1} failed: {e}")
                time.sleep(2)
        logger.error("All Gemini attempts failed")
        return doc
    except Exception as e:
        logger.warning(f"Gemini enhancement failed: {e}")
        return doc

def analyze_structure(elements):
    structures = []
    for elem in elements:
        if elem.get("type") != "text":
            continue
        text = elem.get("text", "").strip()
        font_size = elem.get("font_size", 0)
        page_number = elem.get("page_number", 1)
        if font_size > 14:
            structure = {
                "id": str(uuid.uuid4()),
                "type": "heading",
                "level": 1 if font_size > 18 else 2,
                "title": text,
                "page_number": page_number
            }
            structures.append(structure)
    return structures

def extract_entities(chunks):
    try:
        entity_groups = defaultdict(lambda: {"occurrences": [], "importance": 0})
        relationships = []

        # Process each chunk and collect entity occurrences
        for chunk in chunks:
            if chunk.get("content_type") != "text":
                continue
            text = chunk.get("content", "")
            chunk_id = chunk["id"]
            doc = nlp(text)
            chunk_entities = []

            for ent in doc.ents:
                normalized_name = ent.text.lower()
                entity_type = ent.label_
                key = (normalized_name, entity_type)
                if key not in entity_groups:
                    entity_groups[key] = {
                        "id": uuid.uuid4(),
                        "type": entity_type,
                        "name": ent.text,
                        "normalized_name": normalized_name,
                        "occurrences": [],
                        "importance": 0,
                        "description": ""
                    }
                entity_groups[key]["occurrences"].append({
                    "chunk_id": str(chunk_id),
                    "start": ent.start_char,
                    "end": ent.end_char
                })
                entity_groups[key]["importance"] += 1  # Increment importance per occurrence
                chunk_entities.append(entity_groups[key]["id"])

            # Create relationships between entities in the same chunk
            if len(chunk_entities) > 1:
                for i in range(len(chunk_entities) - 1):
                    for j in range(i + 1, len(chunk_entities)):
                        rel = {
                            "id": uuid.uuid4(),
                            "source_entity_id": chunk_entities[i],
                            "target_entity_id": chunk_entities[j],
                            "type": "co-occurrence",
                            "confidence": 0.5,
                            "description": "Entities appear in the same chunk",
                            "chunk_ids": [str(chunk_id)]
                        }
                        relationships.append(rel)

        # Convert grouped entities to list
        entities = list(entity_groups.values())

        # Normalize importance scores to a 0-1 range
        max_importance = max((entity["importance"] for entity in entities), default=1)  # Avoid ZeroDivisionError
        for entity in entities:
            entity["importance"] = entity["importance"] / max_importance if max_importance > 0 else 0

        logger.info(f"Extracted {len(entities)} unique entities and {len(relationships)} relationships.")
        return entities, relationships
    except Exception as e:
        logger.error(f"Error in entity extraction: {e}")
        raise

def aggregate_metadata(metadata, chunks, structures, entities):
    try:
        summary = ""
        if chunks:
            combined_text = ' '.join([chunk['content'][:1000] for chunk in chunks[:3]]).replace('\x00', '')
            input_length = len(tokenizer.encode(combined_text))
            summary_result = summarizer(
                combined_text,
                max_length=min(300, input_length),
                min_length=max(30, int(input_length * 0.2)),
                do_sample=False
            )
            summary = summary_result[0]["summary_text"].replace('\x00', '')
        entity_types = [e["type"] for e in entities]
        topics = [t[0] for t in Counter(entity_types).most_common(5)]
        metadata["summary"] = summary
        metadata["topics"] = topics
        logger.info(f"Aggregated metadata: summary length {len(summary)}, {len(topics)} topics.")
        return metadata
    except Exception as e:
        logger.error(f"Error in metadata aggregation: {e}")
        raise

def ingest_pdf(file_path):
    """Ingest a PDF, process it, and return results without immediate database storage."""
    try:
        pdf_reader = None
        try:
            pdf_reader = PdfReader(file_path)
            page_count_pypdf2 = len(pdf_reader.pages)
            info = pdf_reader.metadata or {}
            pypdf2_title = info.get('/Title', 'Unknown') or 'Unknown'
            pypdf2_author = info.get('/Author', 'Unknown') or 'Unknown'
        except Exception as e:
            logger.warning(f"PyPDF2 validation failed: {e}")
            pypdf2_title = "Unknown"
            pypdf2_author = "Unknown"
            page_count_pypdf2 = 0

        doc = fitz.open(file_path)
        file_stats = os.stat(file_path)

        llm_text = ""
        for page_num in range(min(2, doc.page_count)):
            page = doc[page_num]
            text_blocks = page.get_text("dict")["blocks"]
            for block in text_blocks:
                if "lines" in block:
                    for line in block["lines"]:
                        text = " ".join([span["text"] for span in line.get("spans", [])]).strip()
                        if text:
                            llm_text += text + "\n"
        llm_title, llm_author, title_score, author_score = extract_title_author_with_llm(llm_text)

        metadata = {
            "id": str(uuid.uuid4()),  # Convert UUID to string for JSON compatibility
            "filename": os.path.basename(file_path),
            "title": llm_title if llm_title != "Unknown" else doc.metadata.get("title", pypdf2_title) or pypdf2_title,
            "author": llm_author if llm_author != "Unknown" else doc.metadata.get("author", pypdf2_author) or pypdf2_author,
            "creation_date": parse_pdf_date(doc.metadata.get("creationDate")),
            "modification_date": parse_pdf_date(doc.metadata.get("modDate")),
            "file_creation_date": datetime.datetime.fromtimestamp(file_stats.st_ctime).isoformat(),
            "file_modification_date": datetime.datetime.fromtimestamp(file_stats.st_mtime).isoformat(),
            "page_count": doc.page_count,
            "file_size": file_stats.st_size,
            "language": "en",
            "document_type": "pdf",
            "table_count": 0,
            "summary": "",
            "topics": []
        }

        elements = []
        chunks = []
        pages = []
        table_count = 0
        chunk_size = CONFIG.get("CHUNK_SIZE", 500)

        md_text = None
        try:
            md_text = pymupdf4llm.to_markdown(file_path)
            logger.info(f"Converted to markdown for table detection: {len(md_text)} characters")
        except Exception as e:
            logger.warning(f"Markdown conversion failed: {e}")

        for page_num in range(doc.page_count):
            page = doc[page_num]
            page_text = ""
            has_table = False

            try:
                text_blocks = page.get_text("dict")["blocks"]
                for block in text_blocks:
                    if "lines" in block:
                        for line in block["lines"]:
                            text = " ".join([span["text"] for span in line.get("spans", [])]).strip()
                            if text:
                                text = text.replace('\x00', '')
                                page_text += text + " "
                                font_size = max([span["size"] for span in line.get("spans", [])], default=0)
                                elements.append({
                                    "type": "text",
                                    "text": text,
                                    "page_number": page_num + 1,
                                    "bbox": [block["bbox"][0], block["bbox"][1], block["bbox"][2], block["bbox"][3]],
                                    "font_size": font_size
                                })
            except Exception as e:
                logger.warning(f"PyMuPDF dict extraction failed for page {page_num + 1}: {e}")

            if not page_text and pdf_reader and page_num < len(pdf_reader.pages):
                try:
                    page_text = (pdf_reader.pages[page_num].extract_text() or "").replace('\x00', '')
                    if page_text:
                        elements.append({
                            "type": "text",
                            "text": page_text,
                            "page_number": page_num + 1,
                            "bbox": [0, 0, 612, 792],
                            "font_size": 0
                        })
                except Exception as e:
                    logger.warning(f"PyPDF2 extraction failed for page {page_num + 1}: {e}")

            if md_text:
                page_markers = [f"# Page {page_num+1}", f"## Page {page_num+1}"]
                next_page_markers = [f"# Page {page_num+2}", f"## Page {page_num+2}"]
                page_start = -1
                for marker in page_markers:
                    if marker in md_text:
                        page_start = md_text.find(marker)
                        break
                page_end = len(md_text)
                for marker in next_page_markers:
                    if marker in md_text:
                        page_end = md_text.find(marker)
                        break
                if page_start >= 0:
                    md_page_text = md_text[page_start:page_end].strip()
                    has_table = "| --- |" in md_page_text
            if not has_table:
                try:
                    tables = page.find_tables()
                    has_table = any(len(t.rows) >= 3 and (t.col_count >= 3 if hasattr(t, 'col_count') else len(t.cells[0]) >= 3 if t.cells else False) for t in tables.tables)
                except Exception as e:
                    logger.warning(f"Table detection failed for page {page_num + 1}: {e}")

            if has_table:
                table_count += 1

            pages.append({
                "document_id": metadata["id"],
                "page_number": page_num + 1,
                "has_table": has_table
            })

            if page_text:
                current_chunk = []
                current_token_count = 0
                chunk_index = len(chunks)
                section_path = [f"Page {page_num + 1}"]
                text_blocks = page_text.split()
                for word in text_blocks:
                    tokens = tokenizer.encode(word)
                    if current_token_count + len(tokens) > chunk_size:
                        if current_chunk:
                            chunk_text = " ".join(current_chunk).replace('\x00', '')
                            chunk_id = str(uuid.uuid4())  # Convert to string
                            embedding = embedder.encode(chunk_text)
                            chunks.append({
                                "id": chunk_id,
                                "document_id": metadata["id"],
                                "page_number": page_num + 1,
                                "chunk_index": chunk_index,
                                "content": chunk_text,
                                "content_type": "text",
                                "section_path": section_path[:],
                                "embedding": embedding.tolist(),
                                "token_count": current_token_count,
                                "importance": 1.2 if page_num == 0 else 1.0
                            })
                            chunk_index += 1
                            current_chunk = []
                            current_token_count = 0
                    current_chunk.append(word)
                    current_token_count += len(tokens)
                if current_chunk:
                    chunk_text = " ".join(current_chunk).replace('\x00', '')
                    chunk_id = str(uuid.uuid4())  # Convert to string
                    embedding = embedder.encode(chunk_text)
                    chunks.append({
                        "id": chunk_id,
                        "document_id": metadata["id"],
                        "page_number": page_num + 1,
                        "chunk_index": chunk_index,
                        "content": chunk_text,
                        "content_type": "text",
                        "section_path": section_path[:],
                        "embedding": embedding.tolist(),
                        "token_count": current_token_count,
                        "importance": 1.2 if page_num == 0 else 1.0
                    })

            if not any(c["page_number"] == page_num + 1 for c in chunks):
                logger.warning(f"No chunks for page {page_num + 1}; adding fallback")
                chunk_id = str(uuid.uuid4())  # Convert to string
                chunks.append({
                    "id": chunk_id,
                    "document_id": metadata["id"],
                    "page_number": page_num + 1,
                    "chunk_index": len(chunks),
                    "content": "No text could be extracted from this page",
                    "content_type": "text",
                    "section_path": [f"Page {page_num + 1}"],
                    "embedding": embedder.encode("No text").tolist(),
                    "token_count": 5,
                    "importance": 0.5
                })

        metadata["table_count"] = table_count
        structures = analyze_structure(elements)
        entities, relationships = extract_entities(chunks)
        metadata = aggregate_metadata(metadata, chunks, structures, entities)

       
        strategic_pages = []
        strategic_pages.extend([0, 1] if doc.page_count > 1 else [0])
        mid = doc.page_count // 2
        strategic_pages.extend([mid-1, mid] if doc.page_count > 3 else [mid])
        strategic_pages.extend([-2, -1] if doc.page_count > 2 else [])
        
        gemini_text = ""
        for p in sorted(set(strategic_pages)):
            if 0 <= p < doc.page_count:
                gemini_text += doc[p].get_text()[:2000] + "\n\n"
        
        metadata = enhance_metadata_gemini(metadata, gemini_text, title_score, author_score)

        for key in ["title", "author", "filename", "summary"]:
            if isinstance(metadata[key], str):
                metadata[key] = metadata[key].replace('\x00', '')

        doc.close()
        logger.info(f"Processed PDF: {len(chunks)} chunks, {table_count} tables, {len(structures)} structures, {len(entities)} entities")
        return metadata, chunks, pages, entities, relationships

    except Exception as e:
        logger.error(f"PDF ingestion failed: {e}")
        logger.debug(traceback.format_exc())
        metadata = {
            "id": str(uuid.uuid4()),
            "filename": os.path.basename(file_path),
            "title": "Error Processing PDF",
            "author": "Unknown",
            "creation_date": datetime.datetime.now().isoformat(),
            "modification_date": datetime.datetime.now().isoformat(),
            "file_creation_date": datetime.datetime.now().isoformat(),
            "file_modification_date": datetime.datetime.now().isoformat(),
            "page_count": 1,
            "file_size": os.path.getsize(file_path),
            "language": "en",
            "document_type": "pdf",
            "table_count": 0,
            "summary": f"Error processing this document: {str(e)}",
            "topics": []
        }
        chunks = [{
            "id": str(uuid.uuid4()),
            "document_id": metadata["id"],
            "page_number": 1,
            "chunk_index": 0,
            "content": f"Error processing PDF: {str(e)}".replace('\x00', ''),
            "content_type": "text",
            "section_path": ["Error"],
            "embedding": [0.0] * 768,
            "token_count": 5,
            "importance": 0.5
        }]
        pages = [{
            "document_id": metadata["id"],
            "page_number": 1,
            "has_table": False
        }]
        return metadata, chunks, pages, [], []

if __name__ == "__main__":
    test_file = r"C:\Users\ASUS TUF\Downloads\sample_docs\Buku_Statsitik_Konsumsi_Pangan_2023.pdf"
    metadata, chunks, pages,  entities, relationships = ingest_pdf(test_file)
    print(f"Title: {metadata['title']}, Author: {metadata['author']}")



================
File: python-backend/search.py
================
# search.py
import time
import numpy as np
from sqlalchemy import func, literal, text
from pgvector.sqlalchemy import Vector
from db import get_db_session, Document, DocumentChunk
from pdf_processing import embedder
import logging
from uuid import UUID
from sqlalchemy.sql.expression import cast
from sentence_transformers import SentenceTransformer  # Direct import

logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
print("Using search.py version with literal() and debug logging - 2025-03-01")

def apply_filters(query, filters):
    """Apply additional filters to a search query."""
    if not filters:
        return query

    has_doc_filters = any(f in filters for f in [
        'author', 'creation_date_start', 'creation_date_end',
        'document_type', 'topics', 'language'
    ])

    if has_doc_filters:
        query = query.join(Document, DocumentChunk.document_id == Document.id)

    if 'author' in filters and filters['author']:
        query = query.filter(Document.author.ilike(f"%{filters['author']}%"))
    if 'creation_date_start' in filters and filters['creation_date_start']:
        query = query.filter(Document.creation_date >= filters['creation_date_start'])
    if 'creation_date_end' in filters and filters['creation_date_end']:
        query = query.filter(Document.creation_date <= filters['creation_date_end'])
    if 'document_type' in filters and filters['document_type']:
        query = query.filter(Document.document_type == filters['document_type'])
    if 'language' in filters and filters['language']:
        query = query.filter(Document.language == filters['language'])
    if 'topics' in filters and filters['topics']:
        topics = filters['topics'] if isinstance(filters['topics'], list) else [filters['topics']]
        query = query.filter(Document.topics.overlap(cast(topics, Document.topics.type)))
    if 'min_page' in filters and filters['min_page'] is not None:
        query = query.filter(DocumentChunk.page_number >= filters['min_page'])
    if 'max_page' in filters and filters['max_page'] is not None:
        query = query.filter(DocumentChunk.page_number <= filters['max_page'])

    return query

def fulltext_search(query, limit=10, offset=0, document_id=None, **filters):
    """Perform PostgreSQL full-text search on document chunks."""
    start_time = time.time()
    session = get_db_session()

    search_terms = " | ".join(term for term in query.split() if len(term) > 2) or query

    try:
        rank = func.ts_rank(
            func.to_tsvector('english', DocumentChunk.content),
            func.to_tsquery('english', search_terms)
        ).label('rank')

        base_query = session.query(
            DocumentChunk.id,
            DocumentChunk.document_id,
            DocumentChunk.page_number,
            DocumentChunk.content,
            DocumentChunk.section_path,
            rank
        ).filter(
            func.to_tsvector('english', DocumentChunk.content).op('@@')(
                func.to_tsquery('english', search_terms)
            )
        )

        if document_id:
            document_id = UUID(document_id) if isinstance(document_id, str) else document_id
            base_query = base_query.filter(DocumentChunk.document_id == document_id)

        base_query = apply_filters(base_query, filters)

        count_query = session.query(func.count(DocumentChunk.id)).filter(
            func.to_tsvector('english', DocumentChunk.content).op('@@')(
                func.to_tsquery('english', search_terms)
            )
        )
        if document_id:
            count_query = count_query.filter(DocumentChunk.document_id == document_id)
        count_query = apply_filters(count_query, filters)
        total_count = count_query.scalar() or 0

        results = base_query.order_by(rank.desc()).offset(offset).limit(limit).all()

        formatted_results = []
        for r in results:
            doc = session.query(Document).filter(Document.id == r.document_id).first()
            formatted_results.append({
                'chunk_id': str(r.id),
                'document_id': str(r.document_id),
                'page_number': r.page_number,
                'content': r.content,
                'section_path': r.section_path,
                'score': float(r.rank),
                'document_info': {
                    'title': doc.title if doc else 'Unknown',
                    'author': doc.author if doc else 'Unknown',
                    'document_type': doc.document_type if doc else 'Unknown'
                }
            })

        elapsed_time = time.time() - start_time
        return {
            'results': formatted_results,
            'total': total_count,
            'query': query,
            'limit': limit,
            'offset': offset,
            'search_type': 'fulltext',
            'execution_time': elapsed_time
        }
    except Exception as e:
        print(f"Full-text search failed: {e}")  # Use print for debugging
        return {'results': [], 'total': 0, 'error': str(e)}

def vector_search(query, limit=10, offset=0, document_id=None, **filters):
    """Perform semantic search using vector similarity."""
    start_time = time.time()
    session = get_db_session()

    try:
        print(f"Vector search query: '{query}' (type: {type(query)})")
        if not isinstance(query, str) or not query.strip():
            print(f"Invalid query: must be a non-empty string, got {query}")
            raise ValueError(f"Query must be a non-empty string, got {query}")

        # Generate embedding
        try:
            embedding = embedder.encode(query)
        except Exception as e:
            print(f"Embedding generation failed: {e}")
            raise ValueError(f"Failed to generate embedding for query '{query}': {str(e)}")

        print(f"Raw embedding type: {type(embedding)}, shape: {getattr(embedding, 'shape', 'N/A')}, sample: {embedding[:5] if isinstance(embedding, (np.ndarray, list)) else embedding}")

        # Ensure flat 1D list
        if isinstance(embedding, np.ndarray):
            if embedding.ndim > 1:
                print(f"Flattening NumPy array embedding: {embedding.shape}")
                embedding = embedding.flatten()
            query_embedding = embedding.tolist()
        elif isinstance(embedding, list):
            if len(embedding) > 0 and isinstance(embedding[0], list):
                print(f"Unwrapping nested list embedding: {len(embedding)} sublists")
                query_embedding = embedding[0]
            else:
                query_embedding = embedding
        else:
            query_embedding = embedding

        # Validate embedding
        if not isinstance(query_embedding, list) or len(query_embedding) != 768:
            print(f"Invalid embedding: expected 1D list of 768 elements, got type: {type(query_embedding)}, length: {len(query_embedding) if isinstance(query_embedding, list) else 'N/A'}, value: {query_embedding[:10] if isinstance(query_embedding, list) else query_embedding}")
            raise ValueError(f"Expected 1D embedding of length 768, got type: {type(query_embedding)}, length: {len(query_embedding) if isinstance(query_embedding, list) else 'N/A'}")

        print(f"Processed embedding length: {len(query_embedding)}, sample: {query_embedding[:5]}")

        # Use literal for proper binding
        distance = DocumentChunk.embedding.op('<=>')(literal(query_embedding, type_=Vector(768))).label('distance')
        similarity = (1 - distance).label('similarity')

        columns = [
            DocumentChunk.id,
            DocumentChunk.document_id,
            DocumentChunk.page_number,
            DocumentChunk.content,
            DocumentChunk.section_path,
            DocumentChunk.importance,
            similarity
        ]
        base_query = session.query(*columns)

        if document_id:
            document_id = UUID(document_id) if isinstance(document_id, str) else document_id
            base_query = base_query.filter(DocumentChunk.document_id == document_id)

        base_query = apply_filters(base_query, filters)

        count_query = session.query(func.count(DocumentChunk.id))
        if document_id:
            count_query = count_query.filter(DocumentChunk.document_id == document_id)
        count_query = apply_filters(count_query, filters)
        total_count = count_query.scalar() or 0

        weighted_similarity = (similarity * DocumentChunk.importance).label('weighted_similarity')
        results = base_query.add_columns(weighted_similarity)\
                           .order_by(weighted_similarity.desc())\
                           .offset(offset).limit(limit).all()

        formatted_results = []
        for r in results:
            doc = session.query(Document).filter(Document.id == r.document_id).first()
            formatted_results.append({
                'chunk_id': str(r.id),
                'document_id': str(r.document_id),
                'page_number': r.page_number,
                'content': r.content,
                'section_path': r.section_path,
                'similarity': float(r.similarity),
                'importance': float(r.importance),
                'score': float(r.weighted_similarity),
                'document_info': {
                    'title': doc.title if doc else 'Unknown',
                    'author': doc.author if doc else 'Unknown',
                    'document_type': doc.document_type if doc else 'Unknown'
                }
            })

        elapsed_time = time.time() - start_time
        return {
            'results': formatted_results,
            'total': total_count,
            'query': query,
            'limit': limit,
            'offset': offset,
            'search_type': 'vector',
            'execution_time': elapsed_time
        }
    except Exception as e:
        print(f"Vector search failed: {e}")  # Use print for debugging
        return {'results': [], 'total': 0, 'error': str(e)}

def hybrid_search(query, limit=10, offset=0, document_id=None, vector_weight=0.65, text_weight=0.35, **filters):
    """Perform hybrid search combining vector similarity and text matching."""
    print("Starting hybrid_search function")
    start_time = time.time()
    session = get_db_session()
    
    try:
        print(f"Query received: '{query}' (type: {type(query)})")
        if not isinstance(query, str) or not query.strip():
            print(f"Validation failed: Query must be a non-empty string, got {query}")
            raise ValueError(f"Query must be a non-empty string, got {query}")

        # Initialize embedder per request
        print("Initializing SentenceTransformer embedder")
        embedder = SentenceTransformer("nomic-ai/nomic-embed-text-v2-moe", trust_remote_code=True, device='cpu')
        
        # Generate embedding
        print("Generating embedding with embedder")
        embedding = embedder.encode(query)
        print(f"Raw embedding: type={type(embedding)}, shape={getattr(embedding, 'shape', 'N/A')}, sample={embedding[:5] if isinstance(embedding, (np.ndarray, list)) else embedding}")

        # Ensure flat 1D list
        if isinstance(embedding, np.ndarray):
            if embedding.ndim > 1:
                print(f"Flattening NumPy array: shape={embedding.shape}")
                embedding = embedding.flatten()
            query_embedding = embedding.tolist()
        elif isinstance(embedding, list):
            if len(embedding) > 0 and isinstance(embedding[0], list):
                print(f"Unwrapping nested list: {len(embedding)} sublists")
                query_embedding = embedding[0]
            else:
                query_embedding = embedding
        else:
            query_embedding = embedding

        # Validate embedding
        if not isinstance(query_embedding, list) or len(query_embedding) != 768:
            print(f"Invalid embedding: type={type(query_embedding)}, length={len(query_embedding) if isinstance(query_embedding, list) else 'N/A'}, value={query_embedding[:10] if isinstance(query_embedding, list) else query_embedding}")
            raise ValueError(f"Expected 1D embedding of length 768, got type={type(query_embedding)}, length={len(query_embedding) if isinstance(query_embedding, list) else 'N/A'}")

        print(f"Processed embedding: length={len(query_embedding)}, sample={query_embedding[:5]}")

        # Use raw SQL with join to documents table
        search_terms = " | ".join(term for term in query.split() if len(term) > 2) or query
        query_sql = text("""
            SELECT 
                dc.id AS chunk_id,
                dc.document_id,
                dc.page_number,
                dc.content,
                dc.section_path,
                dc.importance,
                1 - (dc.embedding <=> :query_embedding) AS vector_sim,
                ts_rank(to_tsvector('english', dc.content), to_tsquery('english', :search_terms)) AS text_rank,
                (:vector_weight * (1 - (dc.embedding <=> :query_embedding)) + :text_weight * COALESCE(ts_rank(to_tsvector('english', dc.content), to_tsquery('english', :search_terms)), 0)) AS combined_score,
                d.title AS doc_title,
                d.author AS doc_author,
                d.document_type AS doc_type
            FROM document_chunks dc
            LEFT JOIN documents d ON dc.document_id = d.id
            ORDER BY combined_score DESC
            LIMIT :limit OFFSET :offset
        """)
        
        results = session.execute(
            query_sql,
            {
                "query_embedding": str(query_embedding),
                "search_terms": search_terms,
                "vector_weight": vector_weight,
                "text_weight": text_weight,
                "limit": limit,
                "offset": offset
            }
        ).fetchall()

        total_count = session.query(func.count(DocumentChunk.id)).scalar() or 0

        formatted_results = [
            {
                'chunk_id': str(r.chunk_id),
                'document_id': str(r.document_id),
                'page_number': r.page_number,
                'content': r.content,
                'section_path': r.section_path,
                'vector_similarity': float(r.vector_sim),
                'text_rank': float(r.text_rank) if r.text_rank else 0.0,
                'score': float(r.combined_score),
                'importance': float(r.importance),
                'document_info': {
                    'title': r.doc_title if r.doc_title else 'Unknown',
                    'author': r.doc_author if r.doc_author else 'Unknown',
                    'document_type': r.doc_type if r.doc_type else 'Unknown'
                }
            } for r in results
        ]

        elapsed_time = time.time() - start_time
        print(f"Search completed: {len(formatted_results)} results in {elapsed_time:.2f} seconds")
        return {
            'results': formatted_results,
            'total': total_count,
            'query': query,
            'limit': limit,
            'offset': offset,
            'search_type': 'hybrid',
            'weights': {'vector': vector_weight, 'text': text_weight},
            'execution_time': elapsed_time
        }
    except Exception as e:
        print(f"Hybrid search failed with exception: {e}")
        return {'results': [], 'total': 0, 'error': str(e)}


================
File: python-backend/utils.py
================
# utils.py
def parse_pdf_date(pdf_date):
    """Parse PDF date format (e.g., 'D:20210601232157') into ISO format."""
    if not pdf_date or not isinstance(pdf_date, str) or not pdf_date.startswith('D:'):
        return None
    try:
        date_str = pdf_date[2:16]
        return f"{date_str[0:4]}-{date_str[4:6]}-{date_str[6:8]}T{date_str[8:10]}:{date_str[10:12]}:{date_str[12:14]}"
    except Exception:
        return None

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: 0 },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: 0 },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"],
      "@/lib/*": ["app/lib/*"]
    },
    "baseUrl": "."
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}



================================================================
End of Codebase
================================================================

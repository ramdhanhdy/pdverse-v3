<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>PDF Viewer</title>
  <script src="https://unpkg.com/pdfjs-dist@4.8.69/build/pdf.min.js"></script>
  <style>
    body, html { margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; }
    #viewerContainer { width: 100%; height: 100%; overflow: auto; }
    .loadingMessage { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); }
  </style>
</head>
<body>
  <div id="viewerContainer"></div>
  <div id="loadingMessage" class="loadingMessage">Loading PDF...</div>

  <script>
    // Set worker location
    window.pdfjsLib = window['pdfjs-dist/build/pdf'];
    window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://unpkg.com/pdfjs-dist@4.8.69/build/pdf.worker.min.js';
    
    // Get PDF URL from query parameter
    const urlParams = new URLSearchParams(window.location.search);
    const pdfUrl = urlParams.get('file');
    
    // Global variables
    let pdfDocument = null;
    let currentPage = 1;
    let currentScale = 1;
    let pageRendering = false;
    let pageNumPending = null;

    if (!pdfUrl) {
      document.getElementById('loadingMessage').textContent = 'Error: No PDF URL provided.';
    } else {
      loadPdf(pdfUrl);
    }

    // Handle messages from parent window
    window.addEventListener('message', function(event) {
      if (!event.data) return;

      console.log('Message received from parent:', event.data);
      
      switch(event.data.type) {
        case 'changePage':
          if (pdfDocument && event.data.pageNumber >= 1 && event.data.pageNumber <= pdfDocument.numPages) {
            currentPage = event.data.pageNumber;
            queueRenderPage(currentPage);
          }
          break;
        case 'zoom':
          if (event.data.scale) {
            currentScale = event.data.scale;
            queueRenderPage(currentPage);
          }
          break;
        case 'search':
          if (event.data.query && pdfDocument) {
            searchPdf(event.data.query);
          }
          break;
      }
    });

    function queueRenderPage(num) {
      if (pageRendering) {
        pageNumPending = num;
      } else {
        renderPage(pdfDocument, num, document.querySelector('.pdfViewer'), currentScale);
      }
    }

    async function searchPdf(query) {
      // Simple search implementation
      console.log(`Searching for: ${query}`);
      // Implement search functionality here
    }

    async function loadPdf(url) {
      try {
        // Load the PDF document
        const loadingTask = pdfjsLib.getDocument(url);
        pdfDocument = await loadingTask.promise;
        
        document.getElementById('loadingMessage').style.display = 'none';
        
        // Create viewer element if it doesn't exist
        let viewer = document.querySelector('.pdfViewer');
        if (!viewer) {
          viewer = document.createElement('div');
          viewer.className = 'pdfViewer';
          document.getElementById('viewerContainer').appendChild(viewer);
        }
        
        // Display first page initially
        currentPage = 1;
        renderPage(pdfDocument, currentPage, viewer, currentScale);
        
        // Notify parent that PDF is loaded
        window.parent.postMessage({ 
          type: 'pdfLoaded', 
          numPages: pdfDocument.numPages 
        }, '*');
      } catch (error) {
        document.getElementById('loadingMessage').textContent = `Error loading PDF: ${error.message}`;
        console.error('Error loading PDF:', error);
        
        // Notify parent about error
        window.parent.postMessage({ 
          type: 'pdfError', 
          error: error.message 
        }, '*');
      }
    }
    
    async function renderPage(pdf, pageNumber, container, scale) {
      pageRendering = true;
      
      try {
        // Get the page
        const page = await pdf.getPage(pageNumber);
        
        // Clear the container
        container.innerHTML = '';
        
        // Create a canvas for this page
        const canvas = document.createElement('canvas');
        container.appendChild(canvas);
        
        const context = canvas.getContext('2d');
        
        // Set scale based on container width and current scale factor
        const viewerContainer = document.getElementById('viewerContainer');
        const desiredWidth = viewerContainer.clientWidth - 20; // Allow for margin
        const viewport = page.getViewport({ scale: 1 });
        const calculatedScale = (desiredWidth / viewport.width) * scale;
        const scaledViewport = page.getViewport({ scale: calculatedScale });
        
        // Set canvas dimensions
        canvas.width = scaledViewport.width;
        canvas.height = scaledViewport.height;
        
        // Render the page
        const renderContext = {
          canvasContext: context,
          viewport: scaledViewport
        };
        
        const renderTask = page.render(renderContext);
        
        await renderTask.promise;
        pageRendering = false;
        
        if (pageNumPending !== null) {
          // New page rendering is pending
          renderPage(pdf, pageNumPending, container, scale);
          pageNumPending = null;
        }
      } catch (error) {
        console.error('Error rendering page:', error);
        pageRendering = false;
      }
    }
  </script>
</body>
</html>
